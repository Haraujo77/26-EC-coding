<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Slash Fields — p5.js (single file)</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; }
    canvas { display: block; }

    #ui {
      position: fixed;
      top: 12px;
      right: 12px;
      width: min(420px, calc(100vw - 24px));
      z-index: 10;
      font: 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: rgba(255,255,255,0.92);
      background: rgba(0,0,0,0.58);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 14px;
      backdrop-filter: blur(10px);
      padding: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    #ui.hidden { display: none; }

    #ui h3 {
      margin: 0 0 8px 0;
      font-size: 12px;
      font-weight: 900;
      letter-spacing: 0.2px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }

    #ui .row { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; margin: 6px 0; }
    #ui label { opacity: 0.9; }
    #ui input[type="range"], #ui select { width: 210px; }

    #ui textarea {
      width: 100%;
      height: 76px;
      resize: vertical;
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 8px;
      outline: none;
      box-sizing: border-box;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    #ui button {
      width: 100%;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.92);
      border-radius: 12px;
      padding: 8px 10px;
      cursor: pointer;
    }
    #ui button:hover { background: rgba(255,255,255,0.12); }

    .tinybtn {
      width: auto !important;
      padding: 6px 8px !important;
      border-radius: 10px !important;
      font-weight: 700;
      font-size: 11px;
      background: rgba(255,255,255,0.07);
    }

    .pill {
      border-radius: 999px !important;
      font-weight: 900;
      letter-spacing: 0.2px;
    }

    #showUI {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 11;
      display: none;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.55);
      color: rgba(255,255,255,0.92);
      border-radius: 999px;
      padding: 8px 10px;
      cursor: pointer;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      font: 12px/1 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      font-weight: 800;
    }
    #showUI:hover { background: rgba(255,255,255,0.08); }

    #hint {
      position: fixed;
      left: 12px;
      bottom: 12px;
      z-index: 10;
      font: 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: rgba(255,255,255,0.82);
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 8px 10px;
      max-width: min(920px, calc(100vw - 24px));
      backdrop-filter: blur(10px);
    }

    #banner {
      position: fixed;
      left: 12px;
      top: 12px;
      z-index: 20;
      font: 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: rgba(255,255,255,0.92);
      background: rgba(180,20,20,0.50);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 12px;
      padding: 8px 10px;
      max-width: min(760px, calc(100vw - 24px));
      backdrop-filter: blur(10px);
      display: none;
    }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
  <div id="banner"></div>

  <button id="showUI" title="Show controls (H)">Show controls (H)</button>

  <div id="ui">
    <h3>
      <span>Slash Fields</span>
      <button id="hideBtn" class="tinybtn" title="Hide controls (H)">Hide (H)</button>
    </h3>

    <div class="row">
      <label for="preset">Preset</label>
      <select id="preset"></select>
    </div>

    <div class="row">
      <label for="mode">Mode</label>
      <select id="mode">
        <option value="glyph">Glyphs (chars)</option>
        <option value="word">Words</option>
        <option value="line">Lines</option>
      </select>
    </div>

    <div class="row">
      <label for="font">Font</label>
      <select id="font"></select>
    </div>

    <div class="row"><label for="density">Density</label><input id="density" type="range" min="8" max="48" step="1" /></div>
    <div class="row" id="row-scale" style="display:none;"><label for="scale">Render scale</label><input id="scale" type="range" min="0.45" max="1" step="0.01" /></div>
    <div class="row"><label for="size">Size</label><input id="size" type="range" min="6" max="80" step="1" /></div>
    <div class="row" id="row-thick" style="display:none;"><label for="thick">Thickness</label><input id="thick" type="range" min="0" max="10" step="0.1" /></div>
    <div class="row" id="row-copies" style="display:none;"><label for="copies">Copies per cell</label><input id="copies" type="range" min="1" max="4" step="1" /></div>
    <div class="row"><label for="speed">Speed</label><input id="speed" type="range" min="0" max="4" step="0.01" /></div>
    

    <div class="row"><label for="tilt">Field rotation</label><input id="tilt" type="range" min="-1.5" max="1.5" step="0.01" /></div>
    <div class="row"><label for="warp">Warp</label><input id="warp" type="range" min="0" max="2" step="0.01" /></div>
    <div class="row"><label for="persp">Perspective</label><input id="persp" type="range" min="0" max="2" step="0.01" /></div>
    <div class="row" id="row-depthFade" style="display:none;"><label for="depthFade">Depth fade</label><input id="depthFade" type="range" min="0.05" max="2.5" step="0.01" /></div>
    <div class="row"><label for="swirl">Swirl</label><input id="swirl" type="range" min="0" max="2" step="0.01" /></div>

    <div class="row" id="row-torsionA"><label for="torsionA">Torsion A</label><input id="torsionA" type="range" min="0" max="6" step="0.01" /></div>
    <div class="row" id="row-torsionB"><label for="torsionB">Torsion B</label><input id="torsionB" type="range" min="0" max="6" step="0.01" /></div>
    <div class="row" id="row-torsionSpeed"><label for="torsionSpeed">Torsion speed</label><input id="torsionSpeed" type="range" min="0" max="3" step="0.01" /></div>

    <div class="row" id="row-trail" style="display:none;"><label for="trail">Trails</label><input id="trail" type="range" min="0" max="255" step="1" /></div>
    <div class="row" id="row-grain" style="display:none;"><label for="grain">Grain</label><input id="grain" type="range" min="0" max="1" step="0.01" /></div>
    <div class="row"><label for="vignette">Vignette</label><input id="vignette" type="range" min="0" max="1" step="0.01" /></div>
    <div class="row"><label for="invert">Invert direction</label><input id="invert" type="checkbox" /></div>

    <div class="row"><label for="text">Line 1 = pattern, rest = overlay</label><span id="fps" class="mono" style="opacity:.8;">-- fps</span></div>
    <textarea id="text" spellcheck="false"></textarea>

    <div class="row" style="grid-template-columns: 1fr 1fr; gap: 8px;">
      <button id="btnIn" class="pill" title="Animate in (I)">IN</button>
      <button id="btnOut" class="pill" title="Animate out (O)">OUT</button>
    </div>

    <div class="row" style="grid-template-columns: 1fr 1fr; gap: 8px;">
      <button id="reset" title="Reset time">Reset time</button>
      <button id="clear" title="Clear trails">Clear</button>
    </div>
  </div>

  <div id="hint">
    Keys: <b>1–9</b> presets · <b>Space</b> pause · <b>S</b> screenshot · <b>H</b> hide controls · <b>C</b> clear · <b>I</b> in · <b>O</b> out. (Shortcuts disabled while typing.)
  </div>

  <script>
  "use strict";

  // ======================================================
  //  EXPOSED VARIABLES (edit freely)
  // ======================================================
  const CONFIG = {
    // Rendering
    renderMode: "glyph",        // "glyph" | "line"
    patternMode: "glyph",       // "glyph" (chars) | "word" (tokens)
    mode: "glyph",              // UI convenience: "glyph" | "word" | "line"
    uiVisible: true,

    // Big perf lever — render into a smaller buffer, then upscale
    renderScale: 1.0,            // 0.45..1.0 (lower = faster)

    // Glyphs
    glyphs: "/",                // repeating pattern (line 1 in textarea overrides)
    words: ["/"],               // tokenized pattern for word-mode
    glyphFont: "Phonic",  // CSS font name
    glyphWeight: 800,
    glyphRotationOffset: 0.0,    // radians

    // Core
    preset: "Wave Grid",
    density: 18,
    glyphSize: 26,
    thickness: 0.0,
    copiesPerCell: 1,
    copySpread: 0.28,

    // Motion
    speed: 1.5,
    invertDirection: false,
    fieldRotation: -0.25,

    // Warp
    warp: 1.0,
    perspective: 1.15,
    swirl: 0.75,

    // 3D torsion controls (used by the tall cube + cylinder)
    torsionA: 2.2,
    torsionB: 1.6,
    torsionSpeed: 1.0,

    // Tall cube
    prismWidth: 0.78,           // half-width in X/Z
    prismHeight: 1.34,          // full height

    // Cylinder
    dillRadius: 0.78,
    dillHalfLen: 1.25,

    // 3D object: Football (simple + stable silhouette)
    footballHalfLen: 1.25,
    footballPointiness: 1.05,
    footballTaperPow: 0.55,
    footballSquashY: 0.80,
    footballSquashZ: 0.80,
    footballDepthBoost: 1.10,
    footballYawAmp: 0.18,
    footballPitchAmp: 0.12,

    // Lighting
    minAlpha: 14,
    maxAlpha: 255,
    vignette: 0.35,
    depthFadePower: 2.5,         // lower = brighter deep marks

    // Trails / look
    trailsAlpha: 0,
    grain: 0.0,

    // Overlay text (optional) — textarea lines 2+ override
    overlayLines: [],
    overlaySize: 26,
    overlayAlpha: 120,

    // Entrance/exit animation (smooth: opacity + distance)
    transitionDuration: 1.1,
    transitionEaseOutPower: 3.0,
    transitionEaseInPower: 2.4,
    transitionAlphaPower: 1.0,
    transitionPosMin: 0.10,
    transitionSizeMin: 0.55,

    // Performance
    pixelDensity: 1,
    sizeQuantStep: 6,
    glyphSpriteMin: 8,
    glyphSpriteMax: 96,
    glyphCacheMax: 220,
    grainTileSize: 256,
    fbmOctaves: 3,

    // Presets (sorted by similarity)
    presets: [
      // Planar waves / interference
      "Wave Grid",
      "Wave Interference",

      // Sweeps / broadcast motion
      "Diagonal Sweep",
      "Clock Sweep",

      // Focus / orbit / lens
      "Orbit Spotlight",
      "Spot Pulse",

      // Rings / pulses
      "Ripple Rings",
      "Shock Rings",
      "Shockwave",
      "Rebound Pulse",

      // Forward drive / tunnel
      "Tunnel Drive",
      "Punch Drive",
      "Forward Rush",

      // Spiral / twist
      "Vortex Twist",
      "Spiral Surge",
      "Helix Coil",

      // 3D objects
      "Sphere Drift",
      "Box Drift",
      "Football Drift",
      "Football Vertical",
      "Torus Drift",
      "Cylinder Spin",
      "Twisted Tall Cube",
      "Twisted Cylinder",

      // Texture / bursts
      "Crumple Noise",
      "Lens Breath",
      "Starburst"
    ],

    // Font menu (uses system-installed fonts if present)
    fontOptions: [
      "Phonic",
      "Martina-Plantijn",
      "ui-monospace",
      "system-ui",
      "serif",
      "sans-serif"
    ]
  };
  window.CONFIG = CONFIG;

  // ======================================================
  //  Self-tests (non-blocking)
  // ======================================================
  function parseTextBlock(text) {
    const safe = String(text ?? "");
    const lines = safe.replace(/\r/g, "").split("\n");

    // IMPORTANT: do NOT trim line 1 — spaces are valid glyphs in glyph-mode.
    const glyphLineRaw = (lines[0] ?? "/");
    const glyphs = (glyphLineRaw.length > 0) ? glyphLineRaw : "/";

    // Word tokens for word-mode: split on whitespace. If only whitespace, fall back to ["/"].
    const words = glyphLineRaw.trim().length ? glyphLineRaw.trim().split(/\s+/g) : ["/"];

    const overlays = lines.slice(1).map(s => s.trim()).filter(Boolean);
    return { glyphs, words, overlays, lines };
  }

  function quantizeSize(px) {
    const step = Math.max(1, CONFIG.sizeQuantStep | 0);
    return Math.max(step, Math.round(px / step) * step);
  }

  (function runSelfTests() {
    try {
      console.assert(typeof CONFIG.glyphs === "string" && CONFIG.glyphs.length > 0, "glyphs must be non-empty");
      console.assert(CONFIG.density > 0, "density must be > 0");
      console.assert(CONFIG.glyphSize > 0, "glyphSize must be > 0");
      console.assert(CONFIG.copiesPerCell >= 1 && CONFIG.copiesPerCell <= 4, "copiesPerCell must be 1..4");
      console.assert(typeof CONFIG.depthFadePower === "number", "depthFadePower must exist");
      console.assert(typeof CONFIG.perspective === "number", "perspective must exist");
      console.assert(typeof CONFIG.transitionDuration === "number", "transitionDuration must exist");
      console.assert(typeof CONFIG.invertDirection === "boolean", "invertDirection must be boolean");
      console.assert(["glyph","word","line"].includes(CONFIG.mode), "mode must be glyph|word|line");
      console.assert(CONFIG.presets.includes("Twisted Tall Cube"), "3D preset Twisted Tall Cube present");
      console.assert(CONFIG.presets.includes("Twisted Cylinder"), "3D preset Twisted Cylinder present");

      {
        const a = parseTextBlock("/\nHELLO\nWORLD");
        console.assert(a.glyphs === "/", "parseTextBlock glyphs");
        console.assert(a.words.length === 1 && a.words[0] === "/", "parseTextBlock words default");
        console.assert(a.overlays.length === 2, "parseTextBlock overlays");
      }
      {
        const b = parseTextBlock("   \r\nX");
        console.assert(b.glyphs === "   ", "spaces-only glyph pattern should be preserved");
        console.assert(b.words.length === 1 && b.words[0] === "/", "spaces-only words should fall back");
        console.assert(b.overlays[0] === "X", "CRLF handled");
      }
      {
        const d = parseTextBlock("TOUCHDOWN GOAL\nTitle");
        console.assert(d.words.length === 2, "word split should find 2 tokens");
        console.assert(d.words[0] === "TOUCHDOWN" && d.words[1] === "GOAL", "word tokens correct");
      }
    } catch (e) {
      console.warn("Self-tests had an issue:", e);
    }
  })();

  // ======================================================
  //  Utilities
  // ======================================================
  const TAU = Math.PI * 2;
  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const lerp = (a, b, t) => a + (b - a) * t;
  const smooth = (t) => t * t * (3 - 2 * t);
  const rot2 = (x, y, a) => {
    const c = Math.cos(a), s = Math.sin(a);
    return [x * c - y * s, x * s + y * c];
  };

  function easeInPow(t, p) {
    const tt = clamp01(t);
    return Math.pow(tt, Math.max(1e-3, p));
  }
  function easeOutPow(t, p) {
    const tt = clamp01(t);
    const pp = Math.max(1e-3, p);
    return 1 - Math.pow(1 - tt, pp);
  }

  function motionTime(tSeconds) {
    return tSeconds * (CONFIG.invertDirection ? -1 : 1);
  }

  function hash2(x, y) {
    let n = (x * 374761393 + y * 668265263) | 0;
    n = (n ^ (n >>> 13)) * 1274126177;
    n = (n ^ (n >>> 16)) >>> 0;
    return (n / 4294967296);
  }
  function vnoise2(x, y) {
    const xi = Math.floor(x), yi = Math.floor(y);
    const xf = x - xi, yf = y - yi;
    const u = smooth(xf), v = smooth(yf);
    const a = hash2(xi, yi);
    const b = hash2(xi + 1, yi);
    const c = hash2(xi, yi + 1);
    const d = hash2(xi + 1, yi + 1);
    const ab = lerp(a, b, u);
    const cd = lerp(c, d, u);
    return lerp(ab, cd, v);
  }
  function fbm(x, y, oct) {
    let v = 0;
    let a = 0.5;
    let f = 1;
    const o = (oct == null) ? 4 : oct;
    for (let i = 0; i < o; i++) {
      v += a * vnoise2(x * f, y * f);
      f *= 2;
      a *= 0.5;
    }
    return v;
  }

  function banner(msg) {
    const el = document.getElementById("banner");
    if (!el) return;
    el.textContent = msg;
    el.style.display = "block";
  }

  // ======================================================
  //  Time
  // ======================================================
  const Time = {
    start: performance.now(),
    pausedAt: 0,
    isPaused: false,
    reset() {
      this.start = performance.now();
      this.pausedAt = 0;
      this.isPaused = false;
    },
    togglePause() {
      this.isPaused = !this.isPaused;
      if (this.isPaused) {
        this.pausedAt = (performance.now() - this.start) / 1000;
      } else {
        this.start = performance.now() - this.pausedAt * 1000;
      }
    },
    nowSeconds() {
      return this.isPaused ? this.pausedAt : ((performance.now() - this.start) / 1000);
    }
  };

  // ======================================================
  //  Entrance / Exit controller
  // ======================================================
  const Transition = {
    value: 1,
    from: 1,
    to: 1,
    t0: 0,
    active: false,
    hidden: false,
    direction: "in",
    justBecameHidden: false,

    in(now, clearFn) {
      this.hidden = false;
      this.justBecameHidden = false;
      this.direction = "in";
      this.from = 0;
      this.to = 1;
      this.value = 0;
      this.t0 = now;
      this.active = true;
      if (typeof clearFn === "function") clearFn(true);
    },

    out(now) {
      this.direction = "out";
      this.justBecameHidden = false;
      this.from = this.value;
      this.to = 0;
      this.t0 = now;
      this.active = true;
    },

    update(now) {
      this.justBecameHidden = false;
      if (!this.active) return;

      const dur = Math.max(0.05, CONFIG.transitionDuration);
      const u = clamp01((now - this.t0) / dur);
      const e = (this.direction === "in")
        ? easeOutPow(u, CONFIG.transitionEaseOutPower)
        : easeInPow(u, CONFIG.transitionEaseInPower);

      this.value = lerp(this.from, this.to, e);

      if (u >= 1) {
        this.active = false;
        this.value = this.to;
        this.hidden = (this.value <= 0.0001);
        if (this.hidden) this.justBecameHidden = true;
      }
    }
  };
  window.Transition = Transition;

  // ======================================================
  //  Field mapping
  // ======================================================
  function mapCell(u, v, t) {
    const r = Math.min(2, Math.sqrt(u * u + v * v));
    const rr = clamp01(r);

    const n = fbm(u * 1.2 + t * 0.18, v * 1.2 - t * 0.14, CONFIG.fbmOctaves);
    const wig = (n - 0.5) * 0.35 * CONFIG.warp;

    let x = u;
    let y = v;
    let z = 0;

    const preset = CONFIG.preset;

    if (preset === "Tunnel Drive") {
      const depth = 0.15 + 3.8 * Math.pow(1 - clamp01(rr), 1.9);
      z = depth + 0.55 * wig;
      const tw = (1 - rr) * CONFIG.swirl;
      const a = tw * 1.2 * Math.sin(t * 0.7);
      [x, y] = rot2(x, y, a);
      x = x * (1 + 0.25 * CONFIG.warp * rr * rr);
      y = y * (1 + 0.10 * CONFIG.warp * rr);

    } else if (preset === "Sphere Drift") {
      const theta = u * Math.PI;
      const phi = v * (Math.PI * 0.52);
      const cx = Math.cos(phi) * Math.sin(theta);
      const cy = Math.sin(phi);
      const cz = Math.cos(phi) * Math.cos(theta);

      const ay = t * 0.42 * CONFIG.speed;
      const ax = 0.55 + 0.22 * Math.sin(t * 0.35);

      let X = cx, Y = cy, Z = cz;
      [X, Z] = rot2(X, Z, ay);
      [Y, Z] = rot2(Y, Z, ax);

      x = X * (1 + 0.12 * wig);
      y = Y * (1 + 0.12 * wig);
      z = 1.45 + Z * 1.45;

    } else if (preset === "Box Drift") {
      const theta = u * Math.PI;
      const phi = v * (Math.PI * 0.52);
      let X = Math.cos(phi) * Math.cos(theta);
      let Y = Math.sin(phi);
      let Z = Math.cos(phi) * Math.sin(theta);

      const m = Math.max(Math.abs(X), Math.abs(Y), Math.abs(Z)) || 1;
      X /= m; Y /= m; Z /= m;

      const ay = t * 0.48 * CONFIG.speed;
      const ax = 0.78 + 0.18 * Math.sin(t * 0.31);
      const az2 = t * 0.16 * CONFIG.speed;
      [X, Z] = rot2(X, Z, ay);
      [Y, Z] = rot2(Y, Z, ax);
      [X, Y] = rot2(X, Y, az2);

      // Match Sphere Drift "zoom" feel
      x = X * (1 + 0.12 * wig);
      y = Y * (1 + 0.12 * wig);
      z = 1.45 + Z * 1.45 + 0.20 * Math.sin(t * 0.9 + rr * 5.0);

    } else if (preset === "Football Drift") {
      const theta = u * Math.PI;
      const z0 = clamp01((v + 1) * 0.5) * 2 - 1;

      const halfLen = CONFIG.footballHalfLen;
      const pointiness = Math.max(0.6, CONFIG.footballPointiness);
      const taperPow = Math.max(0.2, CONFIG.footballTaperPow);
      const squashY = Math.max(0.45, CONFIG.footballSquashY);
      const squashZ = Math.max(0.20, CONFIG.footballSquashZ);

      const az = Math.min(1, Math.abs(z0));
      const rProfile = Math.pow(Math.max(0, 1 - Math.pow(az, pointiness)), taperPow);

      let X = z0 * halfLen;
      const squashYZ = 0.5 * (squashY + squashZ);
      let Y = rProfile * Math.cos(theta) * squashYZ;
      let Z = rProfile * Math.sin(theta) * squashYZ;

      const roll = t * 1.25 * CONFIG.speed;
      [Y, Z] = rot2(Y, Z, roll);
      Z *= (CONFIG.footballDepthBoost || 1.0);

      const yaw = CONFIG.footballYawAmp * Math.sin(t * 0.55 * CONFIG.speed);
      const pitch = CONFIG.footballPitchAmp * Math.sin(t * 0.40 * CONFIG.speed);
      [X, Z] = rot2(X, Z, yaw);
      [X, Y] = rot2(X, Y, pitch);

      x = X;
      y = Y;
      z = 1.22 + Z * 1.35;

    } else if (preset === "Football Vertical") {
      const theta = u * Math.PI;
      const y0 = clamp01((v + 1) * 0.5) * 2 - 1;

      const halfLen = CONFIG.footballHalfLen;
      const pointiness = Math.max(0.6, CONFIG.footballPointiness);
      const taperPow = Math.max(0.2, CONFIG.footballTaperPow);
      const squashY = Math.max(0.45, CONFIG.footballSquashY);
      const squashZ = Math.max(0.20, CONFIG.footballSquashZ);

      const ay = Math.min(1, Math.abs(y0));
      const rProfile = Math.pow(Math.max(0, 1 - Math.pow(ay, pointiness)), taperPow);

      let Y = y0 * halfLen;
      const squashXZ = 0.5 * (squashY + squashZ);
      let X = rProfile * Math.cos(theta) * squashXZ;
      let Z = rProfile * Math.sin(theta) * squashXZ;

      const roll = t * 1.25 * CONFIG.speed;
      [X, Z] = rot2(X, Z, roll);
      Z *= (CONFIG.footballDepthBoost || 1.0);

      const yaw = CONFIG.footballYawAmp * Math.sin(t * 0.55 * CONFIG.speed);
      const pitch = CONFIG.footballPitchAmp * Math.sin(t * 0.40 * CONFIG.speed);
      [Y, Z] = rot2(Y, Z, yaw);
      [X, Y] = rot2(X, Y, pitch);

      x = X;
      y = Y;
      z = 1.22 + Z * 1.35;

    } else if (preset === "Torus Drift") {
      const theta = u * Math.PI;
      const phi = v * Math.PI;
      const R = 1.0;
      const r0 = 0.38;
      const ct = Math.cos(theta), st = Math.sin(theta);
      const cp = Math.cos(phi), sp = Math.sin(phi);
      const rad = R + r0 * cp;

      let X = rad * ct;
      let Y = rad * st;
      let Z = r0 * sp;

      const ay = t * 0.55 * CONFIG.speed;
      const ax = 0.85 + 0.25 * Math.sin(t * 0.27);
      const az2 = t * 0.18 * CONFIG.speed;
      [X, Z] = rot2(X, Z, ay);
      [Y, Z] = rot2(Y, Z, ax);
      [X, Y] = rot2(X, Y, az2);

      x = X * (0.78 + 0.10 * wig);
      y = Y * (0.78 + 0.10 * wig);
      z = 1.35 + Z * 1.55 + 0.25 * Math.sin(t * 0.8 + rr * 6.0);

    } else if (preset === "Cylinder Spin") {
      const theta = u * Math.PI;
      let X = Math.cos(theta);
      let Z = Math.sin(theta);
      let Y = v;

      const twist = (0.65 + 0.35 * Math.sin(t * 0.6)) * (0.35 + 0.65 * CONFIG.swirl);
      const a = twist * Y + t * 0.45 * CONFIG.speed;
      [X, Z] = rot2(X, Z, a);

      const ay = t * 0.50 * CONFIG.speed;
      const ax = 0.65 + 0.25 * Math.sin(t * 0.22);
      [X, Z] = rot2(X, Z, ay);
      [Y, Z] = rot2(Y, Z, ax);

      x = X * (0.92 + 0.10 * wig);
      y = Y * (0.86 + 0.10 * wig);
      z = 1.45 + Z * 1.35 + 0.35 * Math.sin((Y * 2.2 + t) * 1.2);

    } else if (preset === "Twisted Tall Cube") {
      // Tall cube (square perimeter) with torsion along height
      const p = clamp01((u + 1) * 0.5);
      const y0 = clamp01((v + 1) * 0.5) * 2 - 1;

      const halfW = Math.max(0.1, CONFIG.prismWidth);
      const halfH = Math.max(0.2, CONFIG.prismHeight) * 0.5;

      const s = p * 4;
      const seg = Math.floor(s);
      const tt = s - seg;

      let X = 0, Z = 0;
      if (seg === 0) { X = +halfW; Z = lerp(-halfW, +halfW, tt); }
      else if (seg === 1) { Z = +halfW; X = lerp(+halfW, -halfW, tt); }
      else if (seg === 2) { X = -halfW; Z = lerp(+halfW, -halfW, tt); }
      else { Z = -halfW; X = lerp(-halfW, +halfW, tt); }

      let Y = y0 * halfH;

      const tors = (CONFIG.torsionA) * (y0 * 1.25) + t * 0.35 * CONFIG.torsionSpeed;
      [X, Z] = rot2(X, Z, tors);

      const tors2 = (CONFIG.torsionB) * Math.sin(t * 0.55 * CONFIG.torsionSpeed + y0 * 2.2);
      [X, Z] = rot2(X, Z, tors2);

      const yaw = 0.25 * Math.sin(t * 0.22 * CONFIG.speed);
      const pitch = 0.65 + 0.12 * Math.sin(t * 0.18);
      [X, Z] = rot2(X, Z, yaw);
      [Y, Z] = rot2(Y, Z, pitch);

      x = X;
      y = Y;
      z = 1.25 + Z * 1.35;

    } else if (preset === "Twisted Cylinder") {
      // Twisted cylinder with torsion along height
      const theta = u * Math.PI;
      const y0 = clamp01((v + 1) * 0.5) * 2 - 1;

      const R = Math.max(0.12, CONFIG.dillRadius);
      const halfLen = Math.max(0.25, CONFIG.dillHalfLen);

      let X = Math.cos(theta) * R;
      let Z = Math.sin(theta) * R;
      let Y = y0 * halfLen;

      const tors = (CONFIG.torsionA * 0.95) * (y0 * 1.35) + t * 0.42 * CONFIG.torsionSpeed;
      [X, Z] = rot2(X, Z, tors);

      const tors2 = (CONFIG.torsionB * 0.75) * Math.sin(t * 0.70 * CONFIG.torsionSpeed + y0 * 2.8);
      [X, Z] = rot2(X, Z, tors2);

      const yaw = 0.22 * Math.sin(t * 0.26 * CONFIG.speed);
      const pitch = 0.70 + 0.14 * Math.sin(t * 0.20);
      [X, Z] = rot2(X, Z, yaw);
      [Y, Z] = rot2(Y, Z, pitch);

      x = X;
      y = Y;
      z = 1.25 + Z * 1.35;

    } else if (preset === "Vortex Twist") {
      const spin = (1 - rr) * (1 - rr) * (1.8 * CONFIG.swirl);
      const a = spin * 2.3 + t * 0.55 * CONFIG.speed;
      [x, y] = rot2(x, y, a);
      z = 0.35 + 2.2 * (1 - rr) + 0.75 * Math.sin(t * 0.8 + rr * 6 + wig);

    } else if (preset === "Ripple Rings") {
      const wv = Math.sin(rr * 10 - t * 1.35 * CONFIG.speed);
      z = 0.55 + 2.2 * (1 - rr) + 0.95 * wv * CONFIG.warp;
      const a = 0.7 * wv * CONFIG.swirl;
      [x, y] = rot2(x, y, a);

    } else if (preset === "Wave Grid") {
      z = 0.55
        + 0.85 * Math.sin((u * 2.2 + t * 0.9 * CONFIG.speed))
        + 0.85 * Math.sin((v * 2.0 - t * 0.7 * CONFIG.speed));
      z = 0.85 + 0.85 * z * 0.55;
      x = u + 0.12 * wig;
      y = v + 0.10 * wig;

    } else if (preset === "Orbit Spotlight") {
      const a = t * 0.35 * CONFIG.speed;
      const ox = 0.35 * Math.cos(a);
      const oy = 0.25 * Math.sin(a * 1.2);
      const d = Math.sqrt((u - ox) * (u - ox) + (v - oy) * (v - oy));
      z = 0.4 + 2.8 * Math.pow(clamp01(1 - d), 2.2) + 0.55 * wig;
      const sw = CONFIG.swirl * (1 - clamp01(d));
      [x, y] = rot2(u, v, sw * 1.6 + a);

    } else if (preset === "Helix Coil") {
      const rr2 = rr * rr;
      const theta = Math.atan2(v, u);
      const tw = 1.35 * (1 - rr);
      const spin = theta * 4.5 + t * 0.9 * CONFIG.speed;
      const wave = Math.sin(spin + rr * 2.2 * 3.2);
      z = 0.35 + 3.2 * Math.pow(1 - rr, 1.7) + wave * 0.85 * CONFIG.warp;
      const a = tw * 2.2 + 0.6 * wave * CONFIG.swirl + rr2 * 0.35 * Math.sin(t * 0.7);
      [x, y] = rot2(u, v, a);
      x += 0.10 * wig;
      y += 0.10 * wig;

    } else if (preset === "Crumple Noise") {
      const n0 = fbm(u * 2.2 + t * 0.10, v * 2.2 - t * 0.08, Math.max(2, CONFIG.fbmOctaves));
      const n1 = fbm(u * 4.1 - t * 0.06, v * 4.1 + t * 0.07, Math.max(2, CONFIG.fbmOctaves));
      const cr = (n0 - 0.5) + 0.55 * (n1 - 0.5);
      const amt = CONFIG.warp;
      x = u + cr * 0.20 * amt;
      y = v + cr * 0.18 * amt;
      z = 0.55 + 2.35 * (1 - rr) + cr * 1.45 * amt;

    } else if (preset === "Lens Breath") {
      const breath = 0.5 + 0.5 * Math.sin(t * 0.75 * CONFIG.speed);
      const k2 = 1 + 0.85 * (1 - rr) * (1 - rr) * (0.25 + 0.75 * breath);
      x = u * k2 + 0.08 * wig;
      y = v * k2 + 0.08 * wig;
      z = 0.45 + 2.6 * (1 - rr) + 0.55 * Math.sin((u * 1.2 + v * 1.1) * 2.2 - t * 0.9);

    } else if (preset === "Starburst") {
      const spokes = 16;
      const th = Math.atan2(v, u);
      const spoke = 0.5 + 0.5 * Math.sin(th * spokes + t * 1.25 * CONFIG.speed);
      const pulse = 0.5 + 0.5 * Math.sin(t * 0.9 * CONFIG.speed);
      z = 0.5 + 2.6 * (1 - rr) + (spoke - 0.5) * 1.6 * CONFIG.warp * (0.35 + 0.65 * pulse);
      const a = (spoke - 0.5) * 1.25 * CONFIG.swirl + 0.15 * Math.sin(t * 0.7);
      [x, y] = rot2(u, v, a);
      x += 0.10 * wig;
      y += 0.10 * wig;

    } else if (preset === "Shock Rings") {
      const shock = Math.sin(rr * 14 - t * 2.4 * CONFIG.speed);
      const center = Math.pow(1 - rr, 2.4);
      z = 0.45 + 2.9 * (1 - rr) + shock * 1.1 * CONFIG.warp * (0.35 + 0.65 * center);
      const a = (0.9 * shock * CONFIG.swirl + 0.6 * center * CONFIG.swirl) * (0.8 + 0.2 * Math.sin(t * 0.7));
      [x, y] = rot2(u, v, a);
      x += 0.09 * wig;
      y += 0.09 * wig;

    } else if (preset === "Spiral Surge") {
      const th = Math.atan2(v, u);
      const spiral = th * 1.8 + (1 - rr) * 3.5 + t * 1.10 * CONFIG.speed;
      const wave = Math.sin(spiral);
      z = 0.55 + 3.0 * Math.pow(1 - rr, 1.6) + wave * 0.95 * CONFIG.warp;
      const a = (1 - rr) * (1.9 * CONFIG.swirl) + wave * 0.55 * CONFIG.swirl;
      [x, y] = rot2(u, v, a);
      x += 0.10 * wig;
      y += 0.10 * wig;

    } else if (preset === "Punch Drive") {
      const depth = 0.18 + 4.2 * Math.pow(1 - rr, 2.0);
      const p = Math.sin(t * 1.35 * CONFIG.speed + rr * 7.0);
      z = depth + 0.55 * wig + p * 0.85 * CONFIG.warp * (0.35 + 0.65 * (1 - rr));
      const a = (1 - rr) * CONFIG.swirl * (1.25 + 0.30 * p);
      [x, y] = rot2(u, v, a);
      x += 0.08 * wig;
      y += 0.08 * wig;

    } else if (preset === "Clock Sweep") {
      const th = Math.atan2(v, u);
      const sweep = t * 0.85 * CONFIG.speed;
      const hand = Math.cos(th - sweep);
      const band = Math.exp(-Math.pow(rr * 3.2, 2));
      z = 0.65 + 2.4 * (1 - rr) + hand * 0.55 * CONFIG.warp * (0.25 + 0.75 * band);
      const a = (hand * 0.35 * CONFIG.swirl) + (0.25 * (1 - rr) * CONFIG.swirl) * Math.sin(t * 0.55);
      [x, y] = rot2(u + 0.06 * wig, v + 0.06 * wig, a);

    } else if (preset === "Spot Pulse") {
      const p1 = Math.sin(t * 1.15 * CONFIG.speed - rr * 9.5);
      const p2 = Math.sin(t * 0.85 * CONFIG.speed + (u * 1.2 - v * 0.9) * 2.0);
      const wv = (0.65 * p1 + 0.35 * p2);
      z = 0.70 + 2.35 * (1 - rr) + wv * 0.70 * CONFIG.warp;
      const a = wv * 0.55 * CONFIG.swirl;
      [x, y] = rot2(u + 0.08 * wig, v + 0.08 * wig, a);

    } else if (preset === "Diagonal Sweep") {
      const f = 2.7;
      const s1 = Math.sin((u * 1.55 + v * 1.05) * f + t * 1.10 * CONFIG.speed);
      const s2 = Math.sin((v * 1.85 - u * 0.75) * (f * 0.95) - t * 0.92 * CONFIG.speed);
      const wv = (s1 + 0.65 * s2) / 1.65;
      z = 0.65 + 2.0 * (1 - rr) + wv * 0.85 * CONFIG.warp;
      const a = wv * 0.45 * CONFIG.swirl;
      [x, y] = rot2(u + 0.08 * wig, v + 0.08 * wig, a);

    } else if (preset === "Forward Rush") {
      const rush = Math.sin(t * 1.8 * CONFIG.speed + rr * 6.0);
      const depth = 0.25 + 4.1 * Math.pow(1 - rr, 2.1);
      z = depth + rush * 0.75 * CONFIG.warp + 0.45 * wig;
      const a = (1 - rr) * 1.6 * CONFIG.swirl + 0.35 * rush * CONFIG.swirl;
      [x, y] = rot2(u, v, a);
      x = x * (1 + 0.18 * CONFIG.warp * rr);
      y = y * (1 + 0.10 * CONFIG.warp * rr);

    } else if (preset === "Shockwave") {
      const shock = Math.sin(rr * 14.5 - t * 1.65 * CONFIG.speed);
      const damp = Math.exp(-rr * 1.35);
      z = 0.55 + 2.7 * (1 - rr) + shock * damp * 1.25 * CONFIG.warp + 0.35 * wig;
      const a = shock * damp * 0.95 * CONFIG.swirl;
      [x, y] = rot2(u, v, a);
      x += 0.08 * wig;
      y += 0.08 * wig;

    } else if (preset === "Rebound Pulse") {
      const pulse1 = Math.sin(rr * 10 - t * 1.6 * CONFIG.speed);
      const pulse2 = Math.sin(rr * 14 - t * 2.2 * CONFIG.speed + 1.2);
      const wv = 0.6 * pulse1 + 0.4 * pulse2;
      const center = Math.pow(1 - rr, 2.0);
      z = 0.55 + 2.8 * (1 - rr) + wv * 1.05 * CONFIG.warp * (0.4 + 0.6 * center);
      const a = wv * 0.85 * CONFIG.swirl * (0.5 + 0.5 * center);
      [x, y] = rot2(u + 0.09 * wig, v + 0.09 * wig, a);

    } else if (preset === "Wave Interference") {
      const f = 2.6;
      const w1 = Math.sin((u * f + v * 0.65) * 2.1 + t * 1.10 * CONFIG.speed);
      const w2 = Math.sin((v * f - u * 0.55) * 2.3 - t * 0.92 * CONFIG.speed);
      const w3 = Math.sin((u + v) * 3.4 + t * 0.55);
      const wv = (w1 + 0.8 * w2 + 0.6 * w3) / 2.4;
      z = 0.55 + 2.25 * (1 - rr) + wv * 1.25 * CONFIG.warp;
      const a = wv * 0.9 * CONFIG.swirl;
      [x, y] = rot2(u + 0.10 * wig, v + 0.10 * wig, a);
    }

    const persp = Math.max(0, CONFIG.perspective) * 0.85;
    const k = 1 / (1 + z * persp);

    const sx = x * k;
    const sy = y * k;

    const depth01 = clamp01(1 - k);
    const size = lerp(1.65, 0.55, depth01);

    const depthFactor = Math.pow(depth01, Math.max(0.01, CONFIG.depthFadePower));
    const a01 = lerp(1.0, 0.18, depthFactor);

    const fieldTwist = (CONFIG.swirl * 0.55) * (1 - rr) * Math.sin(t * 0.6);
    const angle = CONFIG.fieldRotation + fieldTwist + (wig * 0.9);

    return { nx: sx, ny: sy, scale: size, alpha: a01, angle: angle, rr: rr };
  }

  // ======================================================
  //  UI
  // ======================================================
  function setUIVisible(visible) {
    CONFIG.uiVisible = !!visible;
    const ui = document.getElementById("ui");
    const showBtn = document.getElementById("showUI");
    if (!ui || !showBtn) return;
    if (CONFIG.uiVisible) {
      ui.classList.remove("hidden");
      showBtn.style.display = "none";
    } else {
      ui.classList.add("hidden");
      showBtn.style.display = "block";
    }
  }

  function requireEl(id) {
    const el = document.getElementById(id);
    if (!el) {
      banner("Missing UI element #" + id + ". (The HTML/JS got out of sync.)");
      throw new Error("Missing UI element: #" + id);
    }
    return el;
  }

  function setupUI(restartFn, clearFn, resizeFn, inFn, outFn) {
    const presetEl = requireEl("preset");
    const modeEl = requireEl("mode");
    const densityEl = requireEl("density");
    const scaleEl = requireEl("scale");
    const sizeEl = requireEl("size");
    const thickEl = requireEl("thick");
    const copiesEl = requireEl("copies");
    const speedEl = requireEl("speed");
    const invertEl = requireEl("invert");
    const tiltEl = requireEl("tilt");
    const warpEl = requireEl("warp");
    const perspEl = requireEl("persp");
    const depthFadeEl = requireEl("depthFade");
    const swirlEl = requireEl("swirl");
    const torsionAEl = requireEl("torsionA");
    const torsionBEl = requireEl("torsionB");
    const torsionSpeedEl = requireEl("torsionSpeed");
    const trailEl = requireEl("trail");
    const grainEl = requireEl("grain");
    const fontEl = requireEl("font");
    const vignetteEl = requireEl("vignette");
    const textEl = requireEl("text");
    const inBtn = requireEl("btnIn");
    const outBtn = requireEl("btnOut");
    const resetBtn = requireEl("reset");
    const clearBtn = requireEl("clear");
    const hideBtn = requireEl("hideBtn");
    const showBtn = requireEl("showUI");

    const rowTorsionA = document.getElementById("row-torsionA");
    const rowTorsionB = document.getElementById("row-torsionB");
    const rowTorsionSpeed = document.getElementById("row-torsionSpeed");

    function setRowEnabled(row, enabled) {
      if (!row) return;
      row.style.opacity = enabled ? "1" : "0.32";
      row.style.pointerEvents = enabled ? "auto" : "none";
      row.querySelectorAll("input, select").forEach(el => { el.disabled = !enabled; });
    }

    function applyPresetUI() {
      const torsionOn = (CONFIG.preset === "Twisted Tall Cube" || CONFIG.preset === "Twisted Cylinder");
      setRowEnabled(rowTorsionA, torsionOn);
      setRowEnabled(rowTorsionB, torsionOn);
      setRowEnabled(rowTorsionSpeed, torsionOn);
    }

    presetEl.innerHTML = "";
    for (const p of CONFIG.presets) {
      const opt = document.createElement("option");
      opt.value = p;
      opt.textContent = p;
      presetEl.appendChild(opt);
    }

    // Populate font menu
    fontEl.innerHTML = "";
    const seenFonts = new Set();
    for (const f of (CONFIG.fontOptions || [])) {
      const name = String(f);
      if (seenFonts.has(name)) continue;
      seenFonts.add(name);
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      fontEl.appendChild(opt);
    }

    function setMode(m) {
      CONFIG.mode = m;
      if (m === "line") {
        CONFIG.renderMode = "line";
        CONFIG.patternMode = "glyph";
      } else if (m === "word") {
        CONFIG.renderMode = "glyph";
        CONFIG.patternMode = "word";
      } else {
        CONFIG.renderMode = "glyph";
        CONFIG.patternMode = "glyph";
      }
    }

    function syncToInputs() {
      presetEl.value = CONFIG.preset;
      const m = (CONFIG.renderMode === "line") ? "line" : (CONFIG.patternMode === "word" ? "word" : "glyph");
      modeEl.value = m;
      setMode(m);

      densityEl.value = String(CONFIG.density);
      scaleEl.value = String(CONFIG.renderScale);
      sizeEl.value = String(CONFIG.glyphSize);
      thickEl.value = String(CONFIG.thickness);
      copiesEl.value = String(CONFIG.copiesPerCell);
      speedEl.value = String(CONFIG.speed);
      invertEl.checked = !!CONFIG.invertDirection;
      tiltEl.value = String(CONFIG.fieldRotation);
      warpEl.value = String(CONFIG.warp);
      perspEl.value = String(CONFIG.perspective);
      depthFadeEl.value = String(CONFIG.depthFadePower);
      swirlEl.value = String(CONFIG.swirl);
      torsionAEl.value = String(CONFIG.torsionA);
      torsionBEl.value = String(CONFIG.torsionB);
      torsionSpeedEl.value = String(CONFIG.torsionSpeed);
      trailEl.value = String(CONFIG.trailsAlpha);
      grainEl.value = String(CONFIG.grain);
      fontEl.value = String(CONFIG.glyphFont);
      vignetteEl.value = String(CONFIG.vignette);
      textEl.value = [CONFIG.glyphs, ...(CONFIG.overlayLines || [])].join("\n");
    }

    function parseTextArea() {
      const parsed = parseTextBlock(textEl.value);
      CONFIG.glyphs = parsed.glyphs;
      CONFIG.words = parsed.words;
      CONFIG.overlayLines = parsed.overlays;
    }

    syncToInputs();
    parseTextArea();
    setUIVisible(CONFIG.uiVisible);
    applyPresetUI();

    presetEl.addEventListener("change", () => {
      CONFIG.preset = presetEl.value;
      applyPresetUI();
      restartFn();
    });

    modeEl.addEventListener("change", () => {
      setMode(modeEl.value);
      clearFn();
    });

    densityEl.addEventListener("input", () => { CONFIG.density = parseInt(densityEl.value, 10); });
    scaleEl.addEventListener("input", () => {
      CONFIG.renderScale = Math.max(0.45, Math.min(1, parseFloat(scaleEl.value)));
      resizeFn();
    });
    sizeEl.addEventListener("input", () => { CONFIG.glyphSize = parseFloat(sizeEl.value); });
    thickEl.addEventListener("input", () => { CONFIG.thickness = parseFloat(thickEl.value); });
    copiesEl.addEventListener("input", () => { CONFIG.copiesPerCell = parseInt(copiesEl.value, 10); });
    speedEl.addEventListener("input", () => { CONFIG.speed = parseFloat(speedEl.value); });
    invertEl.addEventListener("change", () => { CONFIG.invertDirection = !!invertEl.checked; });
    tiltEl.addEventListener("input", () => { CONFIG.fieldRotation = parseFloat(tiltEl.value); });
    warpEl.addEventListener("input", () => { CONFIG.warp = parseFloat(warpEl.value); });
    perspEl.addEventListener("input", () => { CONFIG.perspective = parseFloat(perspEl.value); });
    depthFadeEl.addEventListener("input", () => { CONFIG.depthFadePower = parseFloat(depthFadeEl.value); });
    swirlEl.addEventListener("input", () => { CONFIG.swirl = parseFloat(swirlEl.value); });

    torsionAEl.addEventListener("input", () => { CONFIG.torsionA = parseFloat(torsionAEl.value); });
    torsionBEl.addEventListener("input", () => { CONFIG.torsionB = parseFloat(torsionBEl.value); });
    torsionSpeedEl.addEventListener("input", () => { CONFIG.torsionSpeed = parseFloat(torsionSpeedEl.value); });

    trailEl.addEventListener("input", () => { CONFIG.trailsAlpha = parseInt(trailEl.value, 10); });
    grainEl.addEventListener("input", () => { CONFIG.grain = parseFloat(grainEl.value); });
    vignetteEl.addEventListener("input", () => { CONFIG.vignette = parseFloat(vignetteEl.value); resizeFn(); });

    fontEl.addEventListener("change", () => {
      CONFIG.glyphFont = fontEl.value;
      clearFn();
    });

    textEl.addEventListener("input", () => { parseTextArea(); });

    inBtn.addEventListener("click", () => { if (typeof inFn === "function") inFn(); });
    outBtn.addEventListener("click", () => { if (typeof outFn === "function") outFn(); });

    resetBtn.addEventListener("click", () => restartFn());
    clearBtn.addEventListener("click", () => clearFn());

    hideBtn.addEventListener("click", () => setUIVisible(false));
    showBtn.addEventListener("click", () => setUIVisible(true));

    return {
      syncPreset() { presetEl.value = CONFIG.preset; applyPresetUI(); },
      setFPS(v) {
        const fpsEl = document.getElementById("fps");
        if (fpsEl) fpsEl.textContent = v.toFixed(0) + " fps";
      }
    };
  }

  // ======================================================
  //  Token selection (glyph char OR word token)
  // ======================================================
  function pickToken(index) {
    if (CONFIG.patternMode === "word") {
      const arr = Array.isArray(CONFIG.words) && CONFIG.words.length ? CONFIG.words : ["/"];
      const i = ((index % arr.length) + arr.length) % arr.length;
      return String(arr[i]);
    }
    // Default: glyph-mode (character pattern, including spaces)
    const s = (CONFIG.glyphs && String(CONFIG.glyphs).length) ? String(CONFIG.glyphs) : "/";
    const i = ((index % s.length) + s.length) % s.length;
    return s.charAt(i);
  }

  // ======================================================
  //  Script loader
  // ======================================================
  function loadScript(url) {
    return new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = url;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error("Failed to load: " + url));
      document.head.appendChild(s);
    });
  }

  // ======================================================
  //  Keybinds (disabled while typing)
  // ======================================================
  function attachKeybinds(syncPresetFn, onScreenshot, onClear, onIn, onOut) {
    function isTypingInField(evt) {
      const el = evt.target;
      if (!el) return false;
      const tag = (el.tagName || "").toUpperCase();
      if (tag === "TEXTAREA") return true;
      if (tag === "INPUT") {
        const type = (el.getAttribute("type") || "text").toLowerCase();
        return type !== "range" && type !== "checkbox" && type !== "radio" && type !== "button" && type !== "submit" && type !== "reset" && type !== "color";
      }
      if (el.isContentEditable) return true;
      return false;
    }

    window.addEventListener("keydown", (e) => {
      if (isTypingInField(e)) {
        if (e.key === "Escape") {
          try { e.target.blur(); } catch (_) {}
        }
        return;
      }

      if (e.key && e.key.toLowerCase() === "h") {
        setUIVisible(!CONFIG.uiVisible);
        return;
      }
      if (e.code === "Space") {
        Time.togglePause();
        e.preventDefault();
        return;
      }
      if (e.key && e.key.toLowerCase() === "s") { onScreenshot(); return; }
      if (e.key && e.key.toLowerCase() === "c") { onClear(); return; }
      if (e.key && e.key.toLowerCase() === "i") { if (typeof onIn === "function") onIn(); return; }
      if (e.key && e.key.toLowerCase() === "o") { if (typeof onOut === "function") onOut(); return; }

      const k = parseInt(e.key, 10);
      const maxHotkey = Math.min(9, CONFIG.presets.length);
      if (k >= 1 && k <= maxHotkey) {
        CONFIG.preset = CONFIG.presets[k - 1];
        syncPresetFn();
        Time.reset();
        onClear();
      }
    });
  }

  // ======================================================
  //  Boot
  // ======================================================
  (async function boot() {
    try {
      await loadScript("https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/p5.min.js");
    } catch (_) {
      try {
        await loadScript("https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js");
      } catch (_) {
        // ignore
      }
    }

    if (window.p5) {
      startP5();
    } else {
      banner("p5.js could not load here. Running a Canvas2D fallback.");
      startFallback();
    }
  })();

  // ======================================================
  //  p5 renderer (optimized + renderScale)
  // ======================================================
  function startP5() {
    let screenshotFlash = 0;

    let vignetteG = null;
    let grainTile = null;
    let grainTileStamp = 0;

    let pg = null;
    let pgW = 0, pgH = 0;

    // Glyph cache (LRU-capped)
    const glyphCache = new Map();
    let glyphCacheSig = "";

    function cacheGet(key) {
      const v = glyphCache.get(key);
      if (!v) return null;
      glyphCache.delete(key);
      glyphCache.set(key, v);
      return v;
    }
    function cacheSet(key, val) {
      glyphCache.set(key, val);
      const max = Math.max(32, CONFIG.glyphCacheMax | 0);
      while (glyphCache.size > max) {
        const oldest = glyphCache.keys().next().value;
        glyphCache.delete(oldest);
      }
    }

    function clearGlyphCacheIfNeeded() {
      const sig = [CONFIG.glyphFont, CONFIG.glyphWeight, CONFIG.thickness, CONFIG.sizeQuantStep, CONFIG.glyphSpriteMin, CONFIG.glyphSpriteMax].join("|");
      if (sig !== glyphCacheSig) {
        glyphCacheSig = sig;
        glyphCache.clear();
      }
    }

    function getGlyphSprite(p, ch, qSize) {
      clearGlyphCacheIfNeeded();
      const minS = Math.max(4, CONFIG.glyphSpriteMin | 0);
      const maxS = Math.max(minS, CONFIG.glyphSpriteMax | 0);
      const qs = Math.max(minS, Math.min(maxS, qSize | 0));

      const text = String(ch);
      const key = text + "|" + qs + "|" + glyphCacheSig;
      const found = cacheGet(key);
      if (found) return found;

      const dim = Math.ceil(qs * 2.15);
      const g = p.createGraphics(dim, dim);
      g.pixelDensity(1);
      g.clear();

      g.textAlign(g.CENTER, g.CENTER);
      g.textFont(CONFIG.glyphFont);
      g.textStyle(g.BOLD);
      g.textSize(qs);
      g.noStroke();
      g.fill(255);

      // Auto-fit multi-character tokens (word-mode) into the sprite width
      const maxW = dim * 0.92;
      const tw = g.textWidth(text);
      if (tw > maxW && tw > 1) {
        const scale = maxW / tw;
        g.textSize(Math.max(4, qs * scale));
      }

      const passes = Math.max(1, Math.round(CONFIG.thickness));
      const spread = Math.min(2.6, 0.18 * passes);
      for (let i = 0; i < passes; i++) {
        const a = (i / passes) * TAU;
        const dx = Math.cos(a) * spread;
        const dy = Math.sin(a) * spread;
        g.text(text, dim / 2 + dx, dim / 2 + dy);
      }

      cacheSet(key, g);
      return g;
    }

    function rebuildVignette(p) {
      const v = CONFIG.vignette;
      if (v <= 0) {
        vignetteG = null;
        return;
      }
      const w = p.width, h = p.height;
      const g = p.createGraphics(w, h);
      g.pixelDensity(1);
      g.clear();
      const ctx = g.drawingContext;
      const cx = w / 2, cy = h / 2;
      const r0 = Math.min(w, h) * 0.12;
      const r1 = Math.max(w, h) * 0.72;
      const grad = ctx.createRadialGradient(cx, cy, r0, cx, cy, r1);
      grad.addColorStop(0, "rgba(0,0,0,0)");
      grad.addColorStop(1, "rgba(0,0,0," + (0.85 * v) + ")");
      ctx.globalCompositeOperation = "source-over";
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);
      vignetteG = g;
    }

    function rebuildGrainTile(p) {
      const s = Math.max(64, CONFIG.grainTileSize | 0);
      const g = p.createGraphics(s, s);
      g.pixelDensity(1);
      const ctx = g.drawingContext;
      const img = ctx.createImageData(s, s);
      const data = img.data;
      for (let i = 0; i < data.length; i += 4) {
        const v = (Math.random() * 255) | 0;
        data[i] = v;
        data[i + 1] = v;
        data[i + 2] = v;
        data[i + 3] = 255;
      }
      ctx.putImageData(img, 0, 0);
      grainTile = g;
      grainTileStamp = performance.now();
    }

    function ensureBuffer(p) {
      const rs = Math.max(0.45, Math.min(1, CONFIG.renderScale));
      const w = Math.max(1, Math.floor(p.width * rs));
      const h = Math.max(1, Math.floor(p.height * rs));
      if (!pg || w !== pgW || h !== pgH) {
        pgW = w; pgH = h;
        pg = p.createGraphics(pgW, pgH);
        pg.pixelDensity(1);
        pg.background(0);
        try { pg.drawingContext.imageSmoothingEnabled = true; } catch (_) {}
      }
    }

    function drawGrainTiled(p, vis) {
      const g = CONFIG.grain * vis;
      if (g <= 0 || !grainTile) return;
      const age = performance.now() - grainTileStamp;
      if (age > 200) rebuildGrainTile(p);

      p.push();
      p.blendMode(p.OVERLAY);
      p.tint(255, 255 * Math.min(1, g));
      p.imageMode(p.CORNER);
      const s = grainTile.width;
      for (let y = 0; y < p.height; y += s) {
        for (let x = 0; x < p.width; x += s) {
          p.image(grainTile, x, y);
        }
      }
      p.pop();
    }

    function drawOverlayText(p, vis) {
      const lines = CONFIG.overlayLines || [];
      if (!lines.length) return;
      const a = (CONFIG.overlayAlpha * vis);
      if (a <= 0.5) return;
      p.push();
      p.textFont("system-ui");
      p.textStyle(p.BOLD);
      p.textSize(CONFIG.overlaySize);
      p.textAlign(p.LEFT, p.TOP);
      p.noStroke();
      p.fill(255, a);
      let y = 14;
      for (const line of lines) {
        p.text(line, 14, y);
        y += CONFIG.overlaySize * 1.05;
      }
      p.pop();
    }

    function drawLineMark(g, cx, cy, lenPx, angle, thick, alpha) {
      const passes = Math.max(1, Math.round(thick));
      const spread = Math.min(2.2, 0.22 * thick);
      g.push();
      g.translate(cx, cy);
      g.rotate(angle);
      g.stroke(255, alpha);
      g.strokeCap(g.SQUARE);

      for (let i = 0; i < passes; i++) {
        const k = (passes === 1) ? 0 : (i / (passes - 1)) * 2 - 1;
        g.strokeWeight(Math.max(1, thick * 0.55));
        g.line(-lenPx * 0.5, k * spread, lenPx * 0.5, k * spread);
      }
      g.pop();
    }

    function drawGlyphMark(p, g, cx, cy, sizePx, angle, alpha, token) {
      const q = quantizeSize(sizePx);
      const sprite = getGlyphSprite(p, token, q);
      const dim = sprite.width;
      const scale = sizePx / q;

      g.push();
      g.translate(cx, cy);
      g.rotate(angle);
      g.imageMode(g.CENTER);
      g.tint(255, alpha);
      g.image(sprite, 0, 0, dim * scale, dim * scale);
      g.pop();
    }

    let lastClearRequested = false;

    const sketch = (p) => {
      const resizeAll = () => {
        ensureBuffer(p);
        rebuildVignette(p);
        lastClearRequested = true;
      };

      const hardClear = (alsoMain) => {
        lastClearRequested = true;
        if (alsoMain) p.background(0);
      };

      const doIn = () => Transition.in(Time.nowSeconds(), (alsoMain) => hardClear(alsoMain));
      const doOut = () => Transition.out(Time.nowSeconds());

      const ui = setupUI(
        () => { Time.reset(); lastClearRequested = true; },
        () => { lastClearRequested = true; },
        () => { resizeAll(); },
        doIn,
        doOut
      );

      attachKeybinds(
        () => ui.syncPreset(),
        () => { screenshotFlash = 1.0; },
        () => { lastClearRequested = true; },
        doIn,
        doOut
      );

      p.setup = () => {
        try { p.disableFriendlyErrors = true; } catch (_) {}
        p.createCanvas(window.innerWidth, window.innerHeight);
        p.pixelDensity(CONFIG.pixelDensity);
        ensureBuffer(p);
        rebuildVignette(p);
        rebuildGrainTile(p);
        p.background(0);

        const tEl = document.getElementById("text");
        if (tEl && !tEl.value) {
          tEl.value = "/\\nSlash Fields";
          const parsed = parseTextBlock(tEl.value);
          CONFIG.glyphs = parsed.glyphs;
          CONFIG.words = parsed.words;
          CONFIG.overlayLines = parsed.overlays;
        }
      };

      p.windowResized = () => {
        p.resizeCanvas(window.innerWidth, window.innerHeight);
        ensureBuffer(p);
        rebuildVignette(p);
        p.background(0);
        lastClearRequested = true;
      };

      p.draw = () => {
        const t0 = Time.nowSeconds();
        const t = motionTime(t0);
        ui.setFPS(p.frameRate());

        ensureBuffer(p);

        Transition.update(t0);
        const vis = Transition.value;
        const visAlpha = Math.pow(vis, CONFIG.transitionAlphaPower);
        const posMix = lerp(CONFIG.transitionPosMin, 1.0, vis);
        const sizeMix = lerp(CONFIG.transitionSizeMin, 1.0, vis);

        if (Transition.justBecameHidden) {
          if (pg) pg.background(0);
          p.background(0);
          return;
        }

        if (Transition.hidden) {
          if (lastClearRequested) {
            if (pg) pg.background(0);
            lastClearRequested = false;
          }
          p.background(0);
          return;
        }

        if (lastClearRequested) {
          pg.background(0);
          lastClearRequested = false;
        }

        if (CONFIG.trailsAlpha <= 0) {
          pg.background(0);
        } else {
          pg.noStroke();
          pg.fill(0, CONFIG.trailsAlpha);
          pg.rect(0, 0, pgW, pgH);
        }

        const w = pgW;
        const h = pgH;
        const minSide = Math.min(w, h);
        const aspect = w / h;

        const cols = Math.floor(CONFIG.density * aspect);
        const rows = Math.floor(CONFIG.density);
        const countX = Math.max(6, cols);
        const countY = Math.max(6, rows);

        const cx = w * 0.5;
        const cy = h * 0.5;

        const zoom = 1.0 + 0.05 * Math.sin(t * 0.6);
        const copyCount = Math.max(1, Math.min(4, CONFIG.copiesPerCell | 0));
        const spread = clamp01(CONFIG.copySpread);

        const nnFreq = 2.2;

        // Avoid aspect stretching for 3D objects: feed unscaled u0
        const is3D = (
          CONFIG.preset === "Sphere Drift" ||
          CONFIG.preset === "Box Drift" ||
          CONFIG.preset === "Football Drift" ||
          CONFIG.preset === "Football Vertical" ||
          CONFIG.preset === "Torus Drift" ||
          CONFIG.preset === "Cylinder Spin" ||
          CONFIG.preset === "Twisted Tall Cube" ||
          CONFIG.preset === "Twisted Cylinder"
        );

        for (let j = 0; j < countY; j++) {
          const v = (j / (countY - 1)) * 2 - 1;
          for (let i = 0; i < countX; i++) {
            const u0 = (i / (countX - 1)) * 2 - 1;
            const u = u0 * aspect;

            const uIn = is3D ? u0 : u;
            const cell = mapCell(uIn * zoom, v * zoom, t);

            const px0 = cx + cell.nx * (minSide * 0.55);
            const py0 = cy + cell.ny * (minSide * 0.55);

            const px = cx + (px0 - cx) * posMix;
            const py = cy + (py0 - cy) * posMix;

            const nn = vnoise2(u0 * nnFreq + t * 0.08, v * nnFreq - t * 0.06);
            const pulse = 0.80 + 0.28 * Math.sin(t * 1.15 + nn * TAU);

            const size = (CONFIG.glyphSize * cell.scale * pulse) * sizeMix;
            const thick = CONFIG.thickness * cell.scale;

            const edge = clamp01(1 - Math.pow(cell.rr, 1.35));
            const alpha = clamp01(cell.alpha) * edge;
            const a = lerp(CONFIG.minAlpha, CONFIG.maxAlpha, alpha) * visAlpha;

            const baseAng = cell.angle + (nn - 0.5) * 0.30 + CONFIG.glyphRotationOffset;
            const ax = Math.cos(baseAng);
            const ay = Math.sin(baseAng);
            const dist = size * 0.75 * spread;

            for (let c = 0; c < copyCount; c++) {
              const kk = (copyCount === 1) ? 0 : (c / (copyCount - 1)) * 2 - 1;
              const gx = px + ax * kk * dist;
              const gy = py + ay * kk * dist;

              if (CONFIG.renderMode === "line") {
                drawLineMark(pg, gx, gy, size, baseAng, thick, a);
              } else {
                const token = pickToken(i + j * 997 + c * 31);
                drawGlyphMark(p, pg, gx, gy, size, baseAng, a, token);
              }
            }
          }
        }

        p.push();
        p.blendMode(p.BLEND);
        p.imageMode(p.CORNER);
        try { p.drawingContext.imageSmoothingEnabled = true; } catch (_) {}
        p.image(pg, 0, 0, p.width, p.height);
        p.pop();

        if (vignetteG && visAlpha > 0.002) {
          p.push();
          p.blendMode(p.BLEND);
          p.imageMode(p.CORNER);
          p.tint(255, 255 * visAlpha);
          p.image(vignetteG, 0, 0);
          p.pop();
        }

        drawGrainTiled(p, visAlpha);
        drawOverlayText(p, visAlpha);

        if (screenshotFlash > 0) {
          p.push();
          p.noStroke();
          p.fill(255, 30 * screenshotFlash);
          p.rect(0, 0, p.width, p.height);
          p.pop();
          screenshotFlash *= 0.85;
          if (screenshotFlash < 0.05) {
            screenshotFlash = 0;
            try { p.saveCanvas("slash-fields", "png"); } catch (_) {}
          }
        }
      };
    };

    new window.p5(sketch);
  }

  // ======================================================
  //  Canvas2D fallback (simple)
  // ======================================================
  function startFallback() {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d", { alpha: false });
    document.body.insertBefore(canvas, document.body.firstChild);

    function resize() {
      canvas.width = Math.floor(window.innerWidth);
      canvas.height = Math.floor(window.innerHeight);
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener("resize", resize);
    resize();

    let lastT = performance.now();
    let fpsEMA = 60;

    const doIn = () => Transition.in(Time.nowSeconds(), () => { ctx.fillStyle = "black"; ctx.fillRect(0, 0, canvas.width, canvas.height); });
    const doOut = () => Transition.out(Time.nowSeconds());

    const ui = setupUI(
      () => { Time.reset(); },
      () => { ctx.fillStyle = "black"; ctx.fillRect(0, 0, canvas.width, canvas.height); },
      () => { resize(); },
      doIn,
      doOut
    );

    attachKeybinds(
      () => ui.syncPreset(),
      () => {},
      () => { ctx.fillStyle = "black"; ctx.fillRect(0, 0, canvas.width, canvas.height); },
      doIn,
      doOut
    );

    function frame() {
      const now = performance.now();
      const dt = Math.max(1, now - lastT);
      lastT = now;
      fpsEMA = fpsEMA * 0.9 + (1000 / dt) * 0.1;
      ui.setFPS(fpsEMA);

      const t0 = Time.nowSeconds();
      const t = motionTime(t0);
      Transition.update(t0);

      const vis = Transition.value;
      const visAlpha = Math.pow(vis, CONFIG.transitionAlphaPower);
      const posMix = lerp(CONFIG.transitionPosMin, 1.0, vis);
      const sizeMix = lerp(CONFIG.transitionSizeMin, 1.0, vis);

      if (Transition.hidden) {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        requestAnimationFrame(frame);
        return;
      }

      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const w = canvas.width;
      const h = canvas.height;
      const minSide = Math.min(w, h);
      const aspect = w / h;

      const cols = Math.floor(Math.min(CONFIG.density, 22) * aspect);
      const rows = Math.floor(Math.min(CONFIG.density, 22));
      const countX = Math.max(6, cols);
      const countY = Math.max(6, rows);

      const cx = w * 0.5;
      const cy = h * 0.5;

      ctx.strokeStyle = `rgba(255,255,255,${0.85 * visAlpha})`;
      ctx.lineWidth = 1;

      for (let j = 0; j < countY; j++) {
        const v = (j / (countY - 1)) * 2 - 1;
        for (let i = 0; i < countX; i++) {
          const u0 = (i / (countX - 1)) * 2 - 1;
          const u = u0 * aspect;
          const cell = mapCell(u, v, t);

          const px0 = cx + cell.nx * (minSide * 0.55);
          const py0 = cy + cell.ny * (minSide * 0.55);
          const px = cx + (px0 - cx) * posMix;
          const py = cy + (py0 - cy) * posMix;

          const ang = cell.angle;
          const len = (CONFIG.glyphSize * cell.scale) * sizeMix;

          ctx.save();
          ctx.translate(px, py);
          ctx.rotate(ang);
          ctx.beginPath();
          ctx.moveTo(-len * 0.5, 0);
          ctx.lineTo(len * 0.5, 0);
          ctx.stroke();
          ctx.restore();
        }
      }

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);
  }
  </script>
</body>
</html>
