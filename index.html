<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Slash Fields — p5.js (single file)</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; }
    canvas { display: block; }

    #ui {
      position: fixed;
      top: 12px;
      right: 12px;
      width: min(420px, calc(100vw - 24px));
      z-index: 10;
      font: 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: rgba(255,255,255,0.92);
      background: rgba(0,0,0,0.58);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 14px;
      backdrop-filter: blur(10px);
      padding: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    #ui.hidden { display: none; }

    #ui h3 {
      margin: 0 0 8px 0;
      font-size: 12px;
      font-weight: 900;
      letter-spacing: 0.2px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }

    #ui .row { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; margin: 6px 0; }
    #ui label { opacity: 0.9; }
    #ui input[type="range"], #ui select { width: 210px; }

    #ui textarea {
      width: 100%;
      height: 76px;
      resize: vertical;
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.92);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 8px;
      outline: none;
      box-sizing: border-box;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    #ui button {
      width: 100%;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.92);
      border-radius: 12px;
      padding: 8px 10px;
      cursor: pointer;
    }
    #ui button:hover { background: rgba(255,255,255,0.12); }

    .tinybtn {
      width: auto !important;
      padding: 6px 8px !important;
      border-radius: 10px !important;
      font-weight: 700;
      font-size: 11px;
      background: rgba(255,255,255,0.07);
    }

    .pill {
      border-radius: 999px !important;
      font-weight: 900;
      letter-spacing: 0.2px;
    }

    #showUI {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 11;
      display: none;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.55);
      color: rgba(255,255,255,0.92);
      border-radius: 999px;
      padding: 8px 10px;
      cursor: pointer;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      font: 12px/1 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      font-weight: 800;
    }
    #showUI:hover { background: rgba(255,255,255,0.08); }

    #hint {
      position: fixed;
      left: 12px;
      bottom: 12px;
      z-index: 10;
      font: 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: rgba(255,255,255,0.82);
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 8px 10px;
      max-width: min(920px, calc(100vw - 24px));
      backdrop-filter: blur(10px);
    }

    #banner {
      position: fixed;
      left: 12px;
      top: 12px;
      z-index: 20;
      font: 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: rgba(255,255,255,0.92);
      background: rgba(180,20,20,0.50);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 12px;
      padding: 8px 10px;
      max-width: min(760px, calc(100vw - 24px));
      backdrop-filter: blur(10px);
      display: none;
    }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
  <div id="banner"></div>

  <button id="showUI" title="Show controls (H)">Show controls (H)</button>

  <div id="ui">
    <h3>
      <span>Slash Fields</span>
      <button id="hideBtn" class="tinybtn" title="Hide controls (H)">Hide (H)</button>
    </h3>

    <div class="row">
      <label for="preset">Preset</label>
      <select id="preset"></select>
    </div>

    <div class="row">
      <label for="renderMode">Render</label>
      <select id="renderMode">
        <option value="glyph">Glyphs (fast)</option>
        <option value="line">Lines</option>      </select>
    </div>

    <div class="row">
      <label for="font">Font</label>
      <select id="font"></select>
    </div>

    <div class="row"><label for="density">Density</label><input id="density" type="range" min="8" max="48" step="1" /></div>
    <div class="row"><label for="scale">Render scale</label><input id="scale" type="range" min="0.45" max="1" step="0.01" /></div>
    <div class="row"><label for="size">Size</label><input id="size" type="range" min="6" max="80" step="1" /></div>
    <div class="row"><label for="thick">Thickness</label><input id="thick" type="range" min="0" max="10" step="0.1" /></div>
    <div class="row"><label for="copies">Copies per cell</label><input id="copies" type="range" min="1" max="4" step="1" /></div>
    <div class="row"><label for="speed">Speed</label><input id="speed" type="range" min="0" max="4" step="0.01" /></div>
    <div class="row"><label for="tilt">Field rotation</label><input id="tilt" type="range" min="-1.5" max="1.5" step="0.01" /></div>

    <div class="row"><label for="warp">Warp</label><input id="warp" type="range" min="0" max="2" step="0.01" /></div>
    <div class="row"><label for="persp">Perspective</label><input id="persp" type="range" min="0" max="2" step="0.01" /></div>
    <div class="row"><label for="depthFade">Depth fade</label><input id="depthFade" type="range" min="0.05" max="2.5" step="0.01" /></div>
    <div class="row"><label for="swirl">Swirl</label><input id="swirl" type="range" min="0" max="2" step="0.01" /></div>

    <div class="row"><label for="trail">Trails</label><input id="trail" type="range" min="0" max="255" step="1" /></div>
    <div class="row"><label for="grain">Grain</label><input id="grain" type="range" min="0" max="1" step="0.01" /></div>
    <div class="row"><label for="vignette">Vignette</label><input id="vignette" type="range" min="0" max="1" step="0.01" /></div>

    <div class="row"><label for="text">Line 1 = pattern, rest = overlay</label><span id="fps" class="mono" style="opacity:.8;">-- fps</span></div>
    <textarea id="text" spellcheck="false"></textarea>

    <div class="row" style="grid-template-columns: 1fr 1fr; gap: 8px;">
      <button id="btnIn" class="pill" title="Animate in (I)">IN</button>
      <button id="btnOut" class="pill" title="Animate out (O)">OUT</button>
    </div>

    <div class="row" style="grid-template-columns: 1fr 1fr; gap: 8px;">
      <button id="reset" title="Reset time">Reset time</button>
      <button id="clear" title="Clear trails">Clear</button>
    </div>
  </div>

  <div id="hint">
    Keys: <b>1–6</b> presets · <b>Space</b> pause · <b>S</b> screenshot · <b>H</b> hide controls · <b>C</b> clear · <b>I</b> in · <b>O</b> out. (Shortcuts disabled while typing.)
  </div>

  <script>
  "use strict";

  // ======================================================
  //  EXPOSED VARIABLES (edit freely)
  // ======================================================
  const CONFIG = {
    // Rendering
    renderMode: "glyph",        // "glyph" | "line"
    uiVisible: true,

    // Big perf lever — render into a smaller buffer, then upscale
    renderScale: 1.0,           // 0.45..1.0 (lower = faster)

    // Glyphs
    glyphs: "/",               // repeating pattern (line 1 in textarea overrides)
    glyphFont: "ui-monospace", // CSS font name
    glyphWeight: 800,
    glyphRotationOffset: 0.0,   // radians

    // Core
    preset: "WavePlane",
    density: 18,
    glyphSize: 26,
    thickness: 0.0,
    copiesPerCell: 1,
    copySpread: 0.28,

    // Motion
    speed: 1.5,
    fieldRotation: -0.55,

    // Warp
    warp: 1.0,
    perspective: 1.15,
    swirl: 0.75,

    // Lighting
    minAlpha: 14,
    maxAlpha: 255,
    vignette: 0.35,
    depthFadePower: 2.5,       // 0.05..2.5 (lower = brighter deep marks)

    // Trails / look
    trailsAlpha: 0,
    grain: 0.0,

    // Overlay text (optional) — textarea lines 2+ override
    overlayLines: [],
    overlaySize: 26,
    overlayAlpha: 120,

    // Entrance/exit animation (smooth: opacity + distance)
    transitionDuration: 1.1,        // seconds
    transitionEaseOutPower: 3.0,    // IN  : ease-out (fast -> slow)
    transitionEaseInPower: 2.4,     // OUT : ease-in  (slow -> fast)
    transitionAlphaPower: 1.0,      // extra shaping on top of easing (1 = linear)
    transitionPosMin: 0.10,         // 0..1 : how close to center when hidden (0 = center)
    transitionSizeMin: 0.55,        // 0..1 : size multiplier when hidden

    // Performance
    pixelDensity: 1,
    sizeQuantStep: 6,
    glyphSpriteMin: 8,
    glyphSpriteMax: 96,
    glyphCacheMax: 220,
    grainTileSize: 256,
    fbmOctaves: 3,

    // Presets
    presets: ["WavePlane", "Tunnel", "Sphere", "Vortex", "Ripple", "Orbit"],

    // Font menu (uses system-installed fonts if present)
    fontOptions: [
      "ui-monospace",
      "system-ui",
      "serif",
      "sans-serif",
      "Martina-Plantijn",
      "Phonic"
    ]
  }
  window.CONFIG = CONFIG;;
  window.CONFIG = CONFIG;

  // ======================================================
  //  Self-tests (non-blocking)
  // ======================================================
  function parseTextBlock(text) {
    const safe = String(text ?? "");
    const lines = safe.replace(/\r/g, "").split("\n");

    // IMPORTANT: do NOT trim line 1 — spaces are valid glyphs.
    // This lets patterns like "A " (A + trailing space) work.
    const glyphLineRaw = (lines[0] ?? "/");

    // If the user truly leaves line 1 empty, fall back to "/".
    // (But if they type spaces, we keep them as glyphs on purpose.)
    const glyphs = (glyphLineRaw.length > 0) ? glyphLineRaw : "/";

    // Overlay lines: trim + drop empties
    const overlays = lines.slice(1).map(s => s.trim()).filter(Boolean);
    return { glyphs, overlays, lines };
  }

  function quantizeSize(px) {
    const step = Math.max(1, CONFIG.sizeQuantStep | 0);
    return Math.max(step, Math.round(px / step) * step);
  }

  (function runSelfTests() {
    try {
      console.assert(typeof CONFIG.glyphs === "string" && CONFIG.glyphs.length > 0, "glyphs must be non-empty");
      console.assert(CONFIG.density > 0, "density must be > 0");
      console.assert(CONFIG.glyphSize > 0, "glyphSize must be > 0");
      console.assert(CONFIG.copiesPerCell >= 1 && CONFIG.copiesPerCell <= 4, "copiesPerCell must be 1..4");
      console.assert(typeof CONFIG.depthFadePower === "number", "depthFadePower must exist");
      console.assert(typeof CONFIG.perspective === "number", "perspective must exist");
      console.assert(typeof CONFIG.transitionDuration === "number", "transitionDuration must exist");

      {
        const a = parseTextBlock("/\\nHELLO\\nWORLD");
        console.assert(a.glyphs === "/", "parseTextBlock glyphs");
        console.assert(a.overlays.length === 2, "parseTextBlock overlays");
      }
      {
        const b = parseTextBlock("\\r\\n   \\r\\nX");
        console.assert(b.glyphs === "   ", "spaces-only glyph pattern should be preserved");
        console.assert(b.overlays[0] === "X", "CRLF handled");
      }
      {
        const c = parseTextBlock("////\\n\\nA\\n\\nB\\n");
        console.assert(c.glyphs === "////", "should keep pattern");
        console.assert(c.overlays.length === 2, "should ignore empty overlay lines");
      }
      {
        const d = parseTextBlock("A \\nTitle");
        console.assert(d.glyphs.length === 2, "spaces in glyph pattern should be preserved");
        console.assert(d.glyphs.charAt(1) === " ", "trailing space should be a valid glyph");
        console.assert(d.overlays[0] === "Title", "overlay parsing still works");
      }
      {
        const e = parseTextBlock("\\nX");
        console.assert(e.glyphs === "/", "empty first line defaults to /");
        console.assert(e.overlays[0] === "X", "overlay parsing still works");
      }
      {
        const old = CONFIG.sizeQuantStep;
        CONFIG.sizeQuantStep = 4;
        const q = quantizeSize(13);
        console.assert(q === 12 || q === 16, "quantizeSize should snap");
        CONFIG.sizeQuantStep = old;
      }
    } catch (e) {
      console.warn("Self-tests had an issue:", e);
    }
  })();

  // ======================================================
  //  Utilities
  // ======================================================
  const TAU = Math.PI * 2;
  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const lerp = (a, b, t) => a + (b - a) * t;
  const smooth = (t) => t * t * (3 - 2 * t);
  const rot2 = (x, y, a) => {
    const c = Math.cos(a), s = Math.sin(a);
    return [x * c - y * s, x * s + y * c];
  };

  // Transition easing helpers
  function easeInPow(t, p) {
    const tt = clamp01(t);
    return Math.pow(tt, Math.max(1e-3, p));
  }
  function easeOutPow(t, p) {
    const tt = clamp01(t);
    const pp = Math.max(1e-3, p);
    return 1 - Math.pow(1 - tt, pp);
  }

  function hash2(x, y) {
    let n = (x * 374761393 + y * 668265263) | 0;
    n = (n ^ (n >>> 13)) * 1274126177;
    n = (n ^ (n >>> 16)) >>> 0;
    return (n / 4294967296);
  }
  function vnoise2(x, y) {
    const xi = Math.floor(x), yi = Math.floor(y);
    const xf = x - xi, yf = y - yi;
    const u = smooth(xf), v = smooth(yf);
    const a = hash2(xi, yi);
    const b = hash2(xi + 1, yi);
    const c = hash2(xi, yi + 1);
    const d = hash2(xi + 1, yi + 1);
    const ab = lerp(a, b, u);
    const cd = lerp(c, d, u);
    return lerp(ab, cd, v);
  }
  function fbm(x, y, oct) {
    let v = 0;
    let a = 0.5;
    let f = 1;
    const o = (oct == null) ? 4 : oct;
    for (let i = 0; i < o; i++) {
      v += a * vnoise2(x * f, y * f);
      f *= 2;
      a *= 0.5;
    }
    return v;
  }

  function banner(msg) {
    const el = document.getElementById("banner");
    if (!el) return;
    el.textContent = msg;
    el.style.display = "block";
  }

  // ======================================================
  //  Time (pause/resume)
  // ======================================================
  const Time = {
    start: performance.now(),
    pausedAt: 0,
    isPaused: false,
    reset() {
      this.start = performance.now();
      this.pausedAt = 0;
      this.isPaused = false;
    },
    togglePause() {
      this.isPaused = !this.isPaused;
      if (this.isPaused) {
        this.pausedAt = (performance.now() - this.start) / 1000;
      } else {
        this.start = performance.now() - this.pausedAt * 1000;
      }
    },
    nowSeconds() {
      return this.isPaused ? this.pausedAt : ((performance.now() - this.start) / 1000);
    }
  };

  // ======================================================
  //  Entrance / Exit controller (smooth: opacity + distance)
  // ======================================================
  const Transition = {
    value: 1,        // current visibility 0..1 (already eased)
    from: 1,
    to: 1,
    t0: 0,
    active: false,
    hidden: false,
    direction: "in",
    justBecameHidden: false,

    in(now, clearFn) {
      this.hidden = false;
      this.justBecameHidden = false;
      this.direction = "in";
      this.from = 0;
      this.to = 1;
      this.value = 0;
      this.t0 = now;
      this.active = true;
      if (typeof clearFn === "function") clearFn(true);
    },

    out(now) {
      this.direction = "out";
      this.justBecameHidden = false;
      this.from = this.value;
      this.to = 0;
      this.t0 = now;
      this.active = true;
    },

    update(now) {
      this.justBecameHidden = false;
      if (!this.active) return;

      const dur = Math.max(0.05, CONFIG.transitionDuration);
      const u = clamp01((now - this.t0) / dur);
      const e = (this.direction === "in")
        ? easeOutPow(u, CONFIG.transitionEaseOutPower)
        : easeInPow(u, CONFIG.transitionEaseInPower);

      this.value = lerp(this.from, this.to, e);

      if (u >= 1) {
        this.active = false;
        this.value = this.to;
        this.hidden = (this.value <= 0.0001);
        if (this.hidden) this.justBecameHidden = true;
      }
    }
  };
  window.Transition = Transition;

  // ======================================================
  //  Field mapping
  // ======================================================
  function mapCell(u, v, t) {
    const r = Math.min(2, Math.sqrt(u * u + v * v));
    const rr = clamp01(r);

    const n = fbm(u * 1.2 + t * 0.18, v * 1.2 - t * 0.14, CONFIG.fbmOctaves);
    const wig = (n - 0.5) * 0.35 * CONFIG.warp;

    let x = u;
    let y = v;
    let z = 0;

    const preset = CONFIG.preset;

    if (preset === "Tunnel") {
      const depth = 0.15 + 3.8 * Math.pow(1 - clamp01(rr), 1.9);
      z = depth + 0.55 * wig;
      const tw = (1 - rr) * CONFIG.swirl;
      const a = tw * 1.2 * Math.sin(t * 0.7);
      [x, y] = rot2(x, y, a);
      x = x * (1 + 0.25 * CONFIG.warp * rr * rr);
      y = y * (1 + 0.10 * CONFIG.warp * rr);

    } else if (preset === "Sphere") {
      const theta = u * Math.PI;
      const phi = v * (Math.PI * 0.52);
      const cx = Math.cos(phi) * Math.sin(theta);
      const cy = Math.sin(phi);
      const cz = Math.cos(phi) * Math.cos(theta);

      const ay = t * 0.42 * CONFIG.speed;
      const ax = 0.55 + 0.22 * Math.sin(t * 0.35);

      let X = cx;
      let Y = cy;
      let Z = cz;
      [X, Z] = rot2(X, Z, ay);
      [Y, Z] = rot2(Y, Z, ax);

      x = X * (1 + 0.12 * wig);
      y = Y * (1 + 0.12 * wig);
      z = 1.45 + Z * 1.45;

    } else if (preset === "Vortex") {
      const spin = (1 - rr) * (1 - rr) * (1.8 * CONFIG.swirl);
      const a = spin * 2.3 + t * 0.55 * CONFIG.speed;
      [x, y] = rot2(x, y, a);
      z = 0.35 + 2.2 * (1 - rr) + 0.75 * Math.sin(t * 0.8 + rr * 6 + wig);

    } else if (preset === "Ripple") {
      const wv = Math.sin(rr * 10 - t * 1.35 * CONFIG.speed);
      z = 0.55 + 2.2 * (1 - rr) + 0.95 * wv * CONFIG.warp;
      const a = 0.7 * wv * CONFIG.swirl;
      [x, y] = rot2(x, y, a);

    } else if (preset === "WavePlane") {
      z = 0.55
        + 0.85 * Math.sin((u * 2.2 + t * 0.9 * CONFIG.speed))
        + 0.85 * Math.sin((v * 2.0 - t * 0.7 * CONFIG.speed));
      z = 0.85 + 0.85 * z * 0.55;
      x = u + 0.12 * wig;
      y = v + 0.10 * wig;

    } else if (preset === "Orbit") {
      const a = t * 0.35 * CONFIG.speed;
      const ox = 0.35 * Math.cos(a);
      const oy = 0.25 * Math.sin(a * 1.2);
      const d = Math.sqrt((u - ox) * (u - ox) + (v - oy) * (v - oy));
      z = 0.4 + 2.8 * Math.pow(clamp01(1 - d), 2.2) + 0.55 * wig;
      const sw = CONFIG.swirl * (1 - clamp01(d));
      [x, y] = rot2(u, v, sw * 1.6 + a);
    }

    const persp = Math.max(0, CONFIG.perspective) * 0.85;
    const k = 1 / (1 + z * persp);

    const sx = x * k;
    const sy = y * k;

    const depth01 = clamp01(1 - k);
    const size = lerp(1.65, 0.55, depth01);

    // Adjustable depth fade: lower power = brighter deep marks (lets you hit 255 even with high perspective)
    const depthFactor = Math.pow(depth01, Math.max(0.01, CONFIG.depthFadePower));
    const a01 = lerp(1.0, 0.18, depthFactor);

    const fieldTwist = (CONFIG.swirl * 0.55) * (1 - rr) * Math.sin(t * 0.6);
    const angle = CONFIG.fieldRotation + fieldTwist + (wig * 0.9);

    return { nx: sx, ny: sy, scale: size, alpha: a01, angle: angle, rr: rr };
  }

  // ======================================================
  //  UI
  // ======================================================
  function setUIVisible(visible) {
    CONFIG.uiVisible = !!visible;
    const ui = document.getElementById("ui");
    const showBtn = document.getElementById("showUI");
    if (!ui || !showBtn) return;
    if (CONFIG.uiVisible) {
      ui.classList.remove("hidden");
      showBtn.style.display = "none";
    } else {
      ui.classList.add("hidden");
      showBtn.style.display = "block";
    }
  }

  function requireEl(id) {
    const el = document.getElementById(id);
    if (!el) {
      banner("Missing UI element #" + id + ". (The HTML/JS got out of sync.)");
      throw new Error("Missing UI element: #" + id);
    }
    return el;
  }

  function setupUI(restartFn, clearFn, resizeFn, inFn, outFn) {
    const presetEl = requireEl("preset");
    const renderEl = requireEl("renderMode");
    const densityEl = requireEl("density");
    const scaleEl = requireEl("scale");
    const sizeEl = requireEl("size");
    const thickEl = requireEl("thick");
    const copiesEl = requireEl("copies");
    const speedEl = requireEl("speed");
    const tiltEl = requireEl("tilt");
    const warpEl = requireEl("warp");
    const perspEl = requireEl("persp");
    const depthFadeEl = requireEl("depthFade");
    const swirlEl = requireEl("swirl");
    const trailEl = requireEl("trail");
    const grainEl = requireEl("grain");
    const fontEl = requireEl("font");
    const vignetteEl = requireEl("vignette");
    const textEl = requireEl("text");
    const inBtn = requireEl("btnIn");
    const outBtn = requireEl("btnOut");
    const resetBtn = requireEl("reset");
    const clearBtn = requireEl("clear");
    const hideBtn = requireEl("hideBtn");
    const showBtn = requireEl("showUI");

    presetEl.innerHTML = "";
    for (const p of CONFIG.presets) {
      const opt = document.createElement("option");
      opt.value = p;
      opt.textContent = p;
      presetEl.appendChild(opt);
    }

    // Populate font menu
    fontEl.innerHTML = "";
    const seenFonts = new Set();
    for (const f of (CONFIG.fontOptions || [])) {
      const name = String(f);
      if (seenFonts.has(name)) continue;
      seenFonts.add(name);
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      fontEl.appendChild(opt);
    }
    // Ensure current font exists as an option
    if (CONFIG.glyphFont && !seenFonts.has(CONFIG.glyphFont)) {
      const opt = document.createElement("option");
      opt.value = CONFIG.glyphFont;
      opt.textContent = CONFIG.glyphFont;
      fontEl.insertBefore(opt, fontEl.firstChild);
    }

    function syncToInputs() {
      presetEl.value = CONFIG.preset;
      renderEl.value = CONFIG.renderMode;
      densityEl.value = String(CONFIG.density);
      scaleEl.value = String(CONFIG.renderScale);
      sizeEl.value = String(CONFIG.glyphSize);
      thickEl.value = String(CONFIG.thickness);
      copiesEl.value = String(CONFIG.copiesPerCell);
      speedEl.value = String(CONFIG.speed);
      tiltEl.value = String(CONFIG.fieldRotation);
      warpEl.value = String(CONFIG.warp);
      perspEl.value = String(CONFIG.perspective);
      depthFadeEl.value = String(CONFIG.depthFadePower);
      swirlEl.value = String(CONFIG.swirl);
      trailEl.value = String(CONFIG.trailsAlpha);
      grainEl.value = String(CONFIG.grain);
      fontEl.value = String(CONFIG.glyphFont);
      vignetteEl.value = String(CONFIG.vignette);
      textEl.value = [CONFIG.glyphs, ...(CONFIG.overlayLines || [])].join("\n");
    }

    function parseTextArea() {
      const parsed = parseTextBlock(textEl.value);
      CONFIG.glyphs = parsed.glyphs;
      CONFIG.overlayLines = parsed.overlays;
    }

    syncToInputs();
    parseTextArea();
    setUIVisible(CONFIG.uiVisible);

    presetEl.addEventListener("change", () => { CONFIG.preset = presetEl.value; restartFn(); });
    renderEl.addEventListener("change", () => { CONFIG.renderMode = renderEl.value; });

    densityEl.addEventListener("input", () => { CONFIG.density = parseInt(densityEl.value, 10); });
    scaleEl.addEventListener("input", () => {
      CONFIG.renderScale = Math.max(0.45, Math.min(1, parseFloat(scaleEl.value)));
      resizeFn();
    });
    sizeEl.addEventListener("input", () => { CONFIG.glyphSize = parseFloat(sizeEl.value); });
    thickEl.addEventListener("input", () => { CONFIG.thickness = parseFloat(thickEl.value); });
    copiesEl.addEventListener("input", () => { CONFIG.copiesPerCell = parseInt(copiesEl.value, 10); });
    speedEl.addEventListener("input", () => { CONFIG.speed = parseFloat(speedEl.value); });
    tiltEl.addEventListener("input", () => { CONFIG.fieldRotation = parseFloat(tiltEl.value); });
    warpEl.addEventListener("input", () => { CONFIG.warp = parseFloat(warpEl.value); });
    perspEl.addEventListener("input", () => { CONFIG.perspective = parseFloat(perspEl.value); });
    depthFadeEl.addEventListener("input", () => { CONFIG.depthFadePower = parseFloat(depthFadeEl.value); });
    swirlEl.addEventListener("input", () => { CONFIG.swirl = parseFloat(swirlEl.value); });
    trailEl.addEventListener("input", () => { CONFIG.trailsAlpha = parseInt(trailEl.value, 10); });
    grainEl.addEventListener("input", () => { CONFIG.grain = parseFloat(grainEl.value); });
    fontEl.addEventListener("change", () => {
      CONFIG.glyphFont = fontEl.value;
      // Clear trails so the new font is immediately visible
      clearFn();
    });
    vignetteEl.addEventListener("input", () => { CONFIG.vignette = parseFloat(vignetteEl.value); resizeFn(); });

    textEl.addEventListener("input", () => { parseTextArea(); });

    inBtn.addEventListener("click", () => { if (typeof inFn === "function") inFn(); });
    outBtn.addEventListener("click", () => { if (typeof outFn === "function") outFn(); });

    resetBtn.addEventListener("click", () => restartFn());
    clearBtn.addEventListener("click", () => clearFn());

    hideBtn.addEventListener("click", () => setUIVisible(false));
    showBtn.addEventListener("click", () => setUIVisible(true));

    return {
      syncPreset() { presetEl.value = CONFIG.preset; },
      setFPS(v) {
        const fpsEl = document.getElementById("fps");
        if (fpsEl) fpsEl.textContent = v.toFixed(0) + " fps";
      }
    };
  }

  // ======================================================
  //  Glyph selection
  // ======================================================
  function pickGlyph(index) {
    const s = (CONFIG.glyphs && String(CONFIG.glyphs).length) ? String(CONFIG.glyphs) : "/";
    const i = ((index % s.length) + s.length) % s.length;
    return s.charAt(i);
  }

  // ======================================================
  //  Script loader
  // ======================================================
  function loadScript(url) {
    return new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = url;
      s.async = true;
      s.onload = () => resolve();
      s.onerror = () => reject(new Error("Failed to load: " + url));
      document.head.appendChild(s);
    });
  }

  // ======================================================
  //  Keybinds
  // ======================================================
  function attachKeybinds(syncPresetFn, onScreenshot, onClear, onIn, onOut) {
    function isTypingInField(evt) {
      const el = evt.target;
      if (!el) return false;
      const tag = (el.tagName || "").toUpperCase();
      if (tag === "TEXTAREA") return true;
      if (tag === "INPUT") {
        const type = (el.getAttribute("type") || "text").toLowerCase();
        return type !== "range" && type !== "checkbox" && type !== "radio" && type !== "button" && type !== "submit" && type !== "reset" && type !== "color";
      }
      if (el.isContentEditable) return true;
      return false;
    }

    window.addEventListener("keydown", (e) => {
      if (isTypingInField(e)) {
        if (e.key === "Escape") {
          try { e.target.blur(); } catch (_) {}
        }
        return;
      }

      if (e.key && e.key.toLowerCase() === "h") {
        setUIVisible(!CONFIG.uiVisible);
        return;
      }
      if (e.code === "Space") {
        Time.togglePause();
        e.preventDefault();
        return;
      }
      if (e.key && e.key.toLowerCase() === "s") {
        onScreenshot();
        return;
      }
      if (e.key && e.key.toLowerCase() === "c") {
        onClear();
        return;
      }
      if (e.key && e.key.toLowerCase() === "i") {
        if (typeof onIn === "function") onIn();
        return;
      }
      if (e.key && e.key.toLowerCase() === "o") {
        if (typeof onOut === "function") onOut();
        return;
      }

      const k = parseInt(e.key, 10);
      if (k >= 1 && k <= CONFIG.presets.length) {
        CONFIG.preset = CONFIG.presets[k - 1];
        syncPresetFn();
        Time.reset();
        onClear();
      }
    });
  }

  // ======================================================
  //  Boot
  // ======================================================
  (async function boot() {
    try {
      await loadScript("https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/p5.min.js");
    } catch (_) {
      try {
        await loadScript("https://cdn.jsdelivr.net/npm/p5@1.9.4/lib/p5.min.js");
      } catch (_) {
        // ignore
      }
    }

    if (window.p5) {
      startP5();
    } else {
      banner("p5.js could not load here. Running a Canvas2D fallback.");
      startFallback();
    }
  })();

  // ======================================================
  //  p5 renderer (optimized + renderScale)
  // ======================================================
  function startP5() {
    let screenshotFlash = 0;

    let vignetteG = null;
    let grainTile = null;
    let grainTileStamp = 0;

    let pg = null;
    let pgW = 0, pgH = 0;

    // Glyph cache (LRU-capped)
    const glyphCache = new Map();
    let glyphCacheSig = "";

    function cacheGet(key) {
      const v = glyphCache.get(key);
      if (!v) return null;
      glyphCache.delete(key);
      glyphCache.set(key, v);
      return v;
    }
    function cacheSet(key, val) {
      glyphCache.set(key, val);
      const max = Math.max(32, CONFIG.glyphCacheMax | 0);
      while (glyphCache.size > max) {
        const oldest = glyphCache.keys().next().value;
        glyphCache.delete(oldest);
      }
    }

    function clearGlyphCacheIfNeeded() {
      const sig = [CONFIG.glyphFont, CONFIG.glyphWeight, CONFIG.thickness, CONFIG.sizeQuantStep, CONFIG.glyphSpriteMin, CONFIG.glyphSpriteMax].join("|");
      if (sig !== glyphCacheSig) {
        glyphCacheSig = sig;
        glyphCache.clear();
      }
    }

    function getGlyphSprite(p, ch, qSize) {
      clearGlyphCacheIfNeeded();
      const minS = Math.max(4, CONFIG.glyphSpriteMin | 0);
      const maxS = Math.max(minS, CONFIG.glyphSpriteMax | 0);
      const qs = Math.max(minS, Math.min(maxS, qSize | 0));

      const key = ch + "|" + qs + "|" + glyphCacheSig;
      const found = cacheGet(key);
      if (found) return found;

      const dim = Math.ceil(qs * 2.15);
      const g = p.createGraphics(dim, dim);
      g.pixelDensity(1);
      g.clear();

      g.textAlign(g.CENTER, g.CENTER);
      g.textFont(CONFIG.glyphFont);
      g.textStyle(g.BOLD);
      g.textSize(qs);
      g.noStroke();
      g.fill(255);

      const passes = Math.max(1, Math.round(CONFIG.thickness));
      const spread = Math.min(2.6, 0.18 * passes);
      for (let i = 0; i < passes; i++) {
        const a = (i / passes) * TAU;
        const dx = Math.cos(a) * spread;
        const dy = Math.sin(a) * spread;
        g.text(ch, dim / 2 + dx, dim / 2 + dy);
      }

      cacheSet(key, g);
      return g;
    }

    function rebuildVignette(p) {
      const v = CONFIG.vignette;
      if (v <= 0) {
        vignetteG = null;
        return;
      }
      const w = p.width, h = p.height;
      const g = p.createGraphics(w, h);
      g.pixelDensity(1);
      const ctx = g.drawingContext;
      const cx = w / 2, cy = h / 2;
      const r0 = Math.min(w, h) * 0.12;
      const r1 = Math.max(w, h) * 0.72;
      const grad = ctx.createRadialGradient(cx, cy, r0, cx, cy, r1);
      grad.addColorStop(0, "rgba(0,0,0,0)");
      grad.addColorStop(1, "rgba(0,0,0," + (0.78 * v) + ")");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, w, h);
      vignetteG = g;
    }

    function rebuildGrainTile(p) {
      const s = Math.max(64, CONFIG.grainTileSize | 0);
      const g = p.createGraphics(s, s);
      g.pixelDensity(1);
      const ctx = g.drawingContext;
      const img = ctx.createImageData(s, s);
      const data = img.data;
      for (let i = 0; i < data.length; i += 4) {
        const v = (Math.random() * 255) | 0;
        data[i] = v;
        data[i + 1] = v;
        data[i + 2] = v;
        data[i + 3] = 255;
      }
      ctx.putImageData(img, 0, 0);
      grainTile = g;
      grainTileStamp = performance.now();
    }

    function ensureBuffer(p) {
      const rs = Math.max(0.45, Math.min(1, CONFIG.renderScale));
      const w = Math.max(1, Math.floor(p.width * rs));
      const h = Math.max(1, Math.floor(p.height * rs));
      if (!pg || w !== pgW || h !== pgH) {
        pgW = w; pgH = h;
        pg = p.createGraphics(pgW, pgH);
        pg.pixelDensity(1);
        pg.background(0);
        try { pg.drawingContext.imageSmoothingEnabled = true; } catch (_) {}
      }
    }

    function drawGrainTiled(p, vis) {
      const g = CONFIG.grain * vis;
      if (g <= 0 || !grainTile) return;
      const age = performance.now() - grainTileStamp;
      if (age > 200) rebuildGrainTile(p);

      p.push();
      p.blendMode(p.OVERLAY);
      p.tint(255, 255 * Math.min(1, g));
      p.imageMode(p.CORNER);

      const s = grainTile.width;
      for (let y = 0; y < p.height; y += s) {
        for (let x = 0; x < p.width; x += s) {
          p.image(grainTile, x, y);
        }
      }
      p.pop();
    }

    function drawOverlayText(p, vis) {
      const lines = CONFIG.overlayLines || [];
      if (!lines.length) return;
      const a = (CONFIG.overlayAlpha * vis);
      if (a <= 0.5) return;
      p.push();
      p.textFont("system-ui");
      p.textStyle(p.BOLD);
      p.textSize(CONFIG.overlaySize);
      p.textAlign(p.LEFT, p.TOP);
      p.noStroke();
      p.fill(255, a);
      let y = 14;
      for (const line of lines) {
        p.text(line, 14, y);
        y += CONFIG.overlaySize * 1.05;
      }
      p.pop();
    }

    function drawLineMark(g, cx, cy, lenPx, angle, thick, alpha) {
      const passes = Math.max(1, Math.round(thick));
      const spread = Math.min(2.2, 0.22 * thick);
      g.push();
      g.translate(cx, cy);
      g.rotate(angle);
      g.stroke(255, alpha);
      g.strokeCap(g.SQUARE);

      for (let i = 0; i < passes; i++) {
        const k = (passes === 1) ? 0 : (i / (passes - 1)) * 2 - 1;
        g.strokeWeight(Math.max(1, thick * 0.55));
        g.line(-lenPx * 0.5, k * spread, lenPx * 0.5, k * spread);
      }
      g.pop();
    }

    function drawGlyphMark(p, g, cx, cy, sizePx, angle, alpha, glyph) {
      const q = quantizeSize(sizePx);
      const sprite = getGlyphSprite(p, glyph, q);
      const dim = sprite.width;
      const scale = sizePx / q;

      g.push();
      g.translate(cx, cy);
      g.rotate(angle);
      g.imageMode(g.CENTER);
      g.tint(255, alpha);
      g.image(sprite, 0, 0, dim * scale, dim * scale);
      g.pop();
    }

    let lastClearRequested = false;

    const sketch = (p) => {
      const resizeAll = () => {
        ensureBuffer(p);
        rebuildVignette(p);
        lastClearRequested = true;
      };

      const hardClear = (alsoMain) => {
        lastClearRequested = true;
        if (alsoMain) p.background(0);
      };

      const doIn = () => Transition.in(Time.nowSeconds(), (alsoMain) => hardClear(alsoMain));
      const doOut = () => Transition.out(Time.nowSeconds());

      const ui = setupUI(
        () => { Time.reset(); lastClearRequested = true; },
        () => { lastClearRequested = true; },
        () => { resizeAll(); },
        doIn,
        doOut
      );

      attachKeybinds(
        () => ui.syncPreset(),
        () => { screenshotFlash = 1.0; },
        () => { lastClearRequested = true; },
        doIn,
        doOut
      );

      p.setup = () => {
        try { p.disableFriendlyErrors = true; } catch (_) {}
        p.createCanvas(window.innerWidth, window.innerHeight);
        p.pixelDensity(CONFIG.pixelDensity);
        ensureBuffer(p);
        rebuildVignette(p);
        rebuildGrainTile(p);
        p.background(0);

        // Default textarea content
        const tEl = document.getElementById("text");
        if (tEl && !tEl.value) {
          tEl.value = "/ \\nSlash Fields";
          const parsed = parseTextBlock(tEl.value);
          CONFIG.glyphs = parsed.glyphs;
          CONFIG.overlayLines = parsed.overlays;
        }
      };

      p.windowResized = () => {
        p.resizeCanvas(window.innerWidth, window.innerHeight);
        ensureBuffer(p);
        rebuildVignette(p);
        p.background(0);
        lastClearRequested = true;
      };

      p.draw = () => {
        const t = Time.nowSeconds();
        ui.setFPS(p.frameRate());

        ensureBuffer(p);

        // Transition updates (value is already eased)
        Transition.update(t);
        const vis = Transition.value;
        const visAlpha = Math.pow(vis, CONFIG.transitionAlphaPower);
        const posMix = lerp(CONFIG.transitionPosMin, 1.0, vis);
        const sizeMix = lerp(CONFIG.transitionSizeMin, 1.0, vis);

        if (Transition.justBecameHidden) {
          if (pg) pg.background(0);
          p.background(0);
          return;
        }

        if (Transition.hidden) {
          if (lastClearRequested) {
            if (pg) pg.background(0);
            lastClearRequested = false;
          }
          p.background(0);
          return;
        }

        if (lastClearRequested) {
          pg.background(0);
          lastClearRequested = false;
        }

        // Trails
        if (CONFIG.trailsAlpha <= 0) {
          pg.background(0);
        } else {
          pg.noStroke();
          pg.fill(0, CONFIG.trailsAlpha);
          pg.rect(0, 0, pgW, pgH);
        }

        const w = pgW;
        const h = pgH;
        const minSide = Math.min(w, h);
        const aspect = w / h;

        // Constant grid size -> no popping
        const cols = Math.floor(CONFIG.density * aspect);
        const rows = Math.floor(CONFIG.density);
        const countX = Math.max(6, cols);
        const countY = Math.max(6, rows);

        const cx = w * 0.5;
        const cy = h * 0.5;

        const zoom = 1.0 + 0.05 * Math.sin(t * 0.6);
        const copyCount = Math.max(1, Math.min(4, CONFIG.copiesPerCell | 0));
        const spread = clamp01(CONFIG.copySpread);

        if (CONFIG.renderMode === "line") pg.noFill(); else pg.noStroke();

        const nnFreq = 2.2;

        for (let j = 0; j < countY; j++) {
          const v = (j / (countY - 1)) * 2 - 1;
          for (let i = 0; i < countX; i++) {
            const u0 = (i / (countX - 1)) * 2 - 1;
            const u = u0 * aspect;

            const cell = mapCell(u * zoom, v * zoom, t * CONFIG.speed);

            const px0 = cx + cell.nx * (minSide * 0.55);
            const py0 = cy + cell.ny * (minSide * 0.55);

            // Contract toward center when hidden (distance feel)
            const px = cx + (px0 - cx) * posMix;
            const py = cy + (py0 - cy) * posMix;

            const nn = vnoise2(u0 * nnFreq + t * 0.08, v * nnFreq - t * 0.06);
            const pulse = 0.80 + 0.28 * Math.sin(t * 1.15 + nn * TAU);

            const size = (CONFIG.glyphSize * cell.scale * pulse) * sizeMix;
            const thick = CONFIG.thickness * cell.scale;

            const edge = clamp01(1 - Math.pow(cell.rr, 1.35));
            const alpha = clamp01(cell.alpha) * edge;
            const a = lerp(CONFIG.minAlpha, CONFIG.maxAlpha, alpha) * visAlpha;

            const baseAng = cell.angle + (nn - 0.5) * 0.30 + CONFIG.glyphRotationOffset;
            const ax = Math.cos(baseAng);
            const ay = Math.sin(baseAng);
            const dist = size * 0.75 * spread;

            for (let c = 0; c < copyCount; c++) {
              const kk = (copyCount === 1) ? 0 : (c / (copyCount - 1)) * 2 - 1;
              const gx = px + ax * kk * dist;
              const gy = py + ay * kk * dist;

              if (CONFIG.renderMode === "line") {
                drawLineMark(pg, gx, gy, size, baseAng, thick, a);
              } else {
                const glyph = pickGlyph(i + j * 997 + c * 31);
                drawGlyphMark(p, pg, gx, gy, size, baseAng, a, glyph);
              }
            }
          }
        }

        // Present buffer
        p.push();
        p.blendMode(p.BLEND);
        p.imageMode(p.CORNER);
        try { p.drawingContext.imageSmoothingEnabled = true; } catch (_) {}
        p.image(pg, 0, 0, p.width, p.height);
        p.pop();

        // Overlays
        if (vignetteG && visAlpha > 0.002) {
          p.push();
          p.blendMode(p.BLEND);
          p.imageMode(p.CORNER);
          p.tint(255, 255 * visAlpha);
          p.image(vignetteG, 0, 0);
          p.pop();
        }

        drawGrainTiled(p, visAlpha);
        drawOverlayText(p, visAlpha);

        // Screenshot flash + save
        if (screenshotFlash > 0) {
          p.push();
          p.noStroke();
          p.fill(255, 30 * screenshotFlash);
          p.rect(0, 0, p.width, p.height);
          p.pop();
          screenshotFlash *= 0.85;
          if (screenshotFlash < 0.05) {
            screenshotFlash = 0;
            try { p.saveCanvas("slash-fields", "png"); } catch (_) {}
          }
        }
      };
    };

    new window.p5(sketch);
  }

  // ======================================================
  //  Canvas2D fallback (simple)
  // ======================================================
  function startFallback() {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d", { alpha: false });
    document.body.insertBefore(canvas, document.body.firstChild);

    function resize() {
      canvas.width = Math.floor(window.innerWidth);
      canvas.height = Math.floor(window.innerHeight);
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener("resize", resize);
    resize();

    let lastT = performance.now();
    let fpsEMA = 60;

    const doIn = () => Transition.in(Time.nowSeconds(), () => { ctx.fillStyle = "black"; ctx.fillRect(0, 0, canvas.width, canvas.height); });
    const doOut = () => Transition.out(Time.nowSeconds());

    const ui = setupUI(
      () => { Time.reset(); },
      () => { ctx.fillStyle = "black"; ctx.fillRect(0, 0, canvas.width, canvas.height); },
      () => { resize(); },
      doIn,
      doOut
    );

    attachKeybinds(() => ui.syncPreset(), () => {}, () => { ctx.fillStyle = "black"; ctx.fillRect(0, 0, canvas.width, canvas.height); }, doIn, doOut);

    function frame() {
      const now = performance.now();
      const dt = Math.max(1, now - lastT);
      lastT = now;
      fpsEMA = fpsEMA * 0.9 + (1000 / dt) * 0.1;
      ui.setFPS(fpsEMA);

      const t = Time.nowSeconds();
      Transition.update(t);

      const vis = Transition.value;
      const visAlpha = Math.pow(vis, CONFIG.transitionAlphaPower);
      const posMix = lerp(CONFIG.transitionPosMin, 1.0, vis);
      const sizeMix = lerp(CONFIG.transitionSizeMin, 1.0, vis);

      if (Transition.hidden) {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        requestAnimationFrame(frame);
        return;
      }

      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const w = canvas.width;
      const h = canvas.height;
      const minSide = Math.min(w, h);
      const aspect = w / h;

      const cols = Math.floor(Math.min(CONFIG.density, 22) * aspect);
      const rows = Math.floor(Math.min(CONFIG.density, 22));
      const countX = Math.max(6, cols);
      const countY = Math.max(6, rows);

      const cx = w * 0.5;
      const cy = h * 0.5;

      ctx.strokeStyle = `rgba(255,255,255,${0.85 * visAlpha})`;
      ctx.lineWidth = 1;

      for (let j = 0; j < countY; j++) {
        const v = (j / (countY - 1)) * 2 - 1;
        for (let i = 0; i < countX; i++) {
          const u0 = (i / (countX - 1)) * 2 - 1;
          const u = u0 * aspect;
          const cell = mapCell(u, v, t * CONFIG.speed);

          const px0 = cx + cell.nx * (minSide * 0.55);
          const py0 = cy + cell.ny * (minSide * 0.55);
          const px = cx + (px0 - cx) * posMix;
          const py = cy + (py0 - cy) * posMix;

          const ang = cell.angle;
          const len = (CONFIG.glyphSize * cell.scale) * sizeMix;

          ctx.save();
          ctx.translate(px, py);
          ctx.rotate(ang);
          ctx.beginPath();
          ctx.moveTo(-len * 0.5, 0);
          ctx.lineTo(len * 0.5, 0);
          ctx.stroke();
          ctx.restore();
        }
      }

      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);
  }
  </script>
</body>
</html>
